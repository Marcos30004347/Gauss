#include "Integer.hpp"
#include <cstddef>
#include <initializer_list>
#include <string>

namespace ast_teste {

struct ast {
  // *****************
  // Node metadata
  // *****************
  long long ref_count = 0;

  enum kind {
    fact = (1 << 0),
    pow = (1 << 1),
    mul = (1 << 2),
    add = (1 << 3),
    sub = (1 << 4),
    div = (1 << 5),
    sqrt = (1 << 6),
    infinity = (1 << 7),
    negative_infinity = (1 << 8),
    undefined = (1 << 9),
    integer = (1 << 10),
    fraction = (1 << 11),
    symbol = (1 << 12),
    fail = (1 << 13),
    funcall = (1 << 14),
    constant = integer | fraction,
    summable = mul | pow | symbol,
    multiplicable = pow | symbol | add,
    nonconstant = symbol | funcall,
    terminal = fail | undefined | fail | infinity | negative_infinity | symbol |
               integer | fraction,
    ordered = pow | div | sqrt | funcall
  };

  enum format {
    default_format = 0,
    poly_expr_format = 1,
  };

  const static size_t childs_margin = 8;

  // **********************
  // Node metadata members
  // **********************

  // The kind of the Node
  kind kind_of = kind::undefined;

  // format that the ast is formated
  format ast_format = format::default_format;

  // the number of operands on child array
  size_t size_of = 0;

  // the number of pre allocated ast* in the childs array
  size_t ast_reserved_size = 0;

  // array of childs of this node
  ast **ast_childs;

  // ******************
  // Node data members
  // ******************

  union {
    char *ast_sym;
    Int *ast_int;
  };
};

inline ast *ast_inc_ref(ast *a) {
  a->ref_count = a->ref_count + 1;
  return a;
}

inline ast *ast_dec_ref(ast *a) {
  assert(a->ref_count > 0);
  a->ref_count = a->ref_count - 1;
  return a;
}

void ast_delete(ast *a);

void insert(ast *a, ast *b, size_t idx);

void remove(ast *a, size_t idx);

ast *sort(ast *a);

ast *create(ast::kind kind);

ast *create(ast::kind kind, std::initializer_list<ast *>);

ast *symbol(const char *id);

ast *integer(Int value);

ast *fraction(Int num, Int den);

ast *ast_rational(Int num, Int den);

ast *ast_copy(ast *a);

inline ast *operand(ast *a, size_t i) { return a->ast_childs[i]; }

inline int is(ast *a, int k) { return a->kind_of & k; }

inline size_t size_of(ast *ast) { return ast->size_of; }

inline ast::kind kind_of(ast *ast) { return ast->kind_of; }

inline char *get_id(ast *ast) { return ast->ast_sym; }

inline Int get_val(ast *ast) { return Int(*ast->ast_int); }

inline char *get_func_id(ast *ast) { return ast->ast_sym; }

std::string to_string(ast *a);

int compare(ast *a, ast *b, ast::kind ctx);

ast *reduce(ast *a, bool print = false, ast *parent = nullptr);

ast *expand(ast *a);

void ast_print(ast *a, int tabs = 0);

class expression {
  ast *root = 0;
	expression* child = 0;

	explicit expression(ast *d);

  ast *remove_data();

	expression();

public:
  expression(Int v);
  expression(int v);
  expression(long int v);
  expression(long long v);

	expression(expression &);
  expression(expression &&);

  expression(std::string v);

  ~expression();

  expression &operator[](size_t i);

  expression operator+(expression &a);
  expression operator+(expression &&a);

  expression operator-(expression &a);
  expression operator-(expression &&a);

  expression operator*(expression &a);
  expression operator*(expression &&a);

  expression operator/(expression &a);
  expression operator/(expression &&a);

  expression &operator=(expression &a);
  expression &operator=(expression &&a);

  void printAST() const;
	std::string toString() const;
};

} // namespace ast_teste
