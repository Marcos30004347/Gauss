#include "AST3.hpp"

//#include <algorithm>
#include <algorithm>
#include <cstddef>
#include <cstdlib>
#include <cstring>
#include <initializer_list>
#include <random>
#include <string>

namespace ast_teste {

ast *ast_create(ast::kind kind) {
  ast *a = (ast *)malloc(sizeof(ast));

  a->ast_kind = kind;

  a->ast_childs = nullptr;

  a->ast_format = ast::default_format;

  a->ast_size = 0;

  a->ast_reserved_size = 0;

  return a;
}

ast *ast_create(ast::kind kind, std::initializer_list<ast *> l) {
  ast *a = (ast *)malloc(sizeof(ast));

  a->ast_kind = kind;

  a->ast_format = ast::default_format;

  a->ast_size = l.size();

  a->ast_reserved_size = a->ast_size;

  a->ast_childs = (ast **)(malloc(sizeof(void (ast::*)()) * l.size()));

  memcpy(a->ast_childs, l.begin(), (size_t)l.end() - (size_t)l.begin());

  return a;
}

int ast_is_kind(ast *a, int k) { return a->ast_kind & k; }

void ast_delete(ast *a) {
  for (size_t i = 0; i < ast_size(a); i++) {
    ast_delete(ast_operand(a, i));
  }

  if (ast_is_kind(a, ast::symbol)) {
    delete a->ast_id;
  }

  if (ast_is_kind(a, ast::integer)) {
    delete a->ast_int_val;
  }

  if (a->ast_childs) {
    free(a->ast_childs);
  }

  free(a);
}

ast *ast_symbol(std::string id) {
  ast *a = ast_create(ast::symbol);

  a->ast_id = new std::string(id);

  return a;
}

ast *ast_integer(Int value) {
  ast *a = ast_create(ast::integer);

  a->ast_int_val = new Int(value);

  return a;
}

ast *ast_fraction(Int num, Int den) {
  return ast_create(ast::fraction, {ast_integer(num), ast_integer(den)});
}

ast *ast_operand(ast *a, size_t i) { return a->ast_childs[i]; }

void ast_insert(ast *a, ast *b, size_t idx) {
  assert(a->ast_size >= idx);

  const size_t ast_size = sizeof(void (ast::*)());

  if (a->ast_reserved_size == a->ast_size) {

    ast **childs =
        (ast **)malloc(ast_size * (a->ast_size + ast::childs_margin));

    a->ast_reserved_size = a->ast_size + ast::childs_margin;

    memcpy(childs, a->ast_childs, ast_size * idx);

    childs[idx] = b;

    if (idx > a->ast_size) {
      memcpy(childs + idx + 1, a->ast_childs + idx,
             ast_size * (a->ast_size - idx));
    }

    free(a->ast_childs);

    a->ast_childs = childs;
  } else {
    if (idx == a->ast_size) {
      a->ast_childs[idx] = b;
    } else {
      memcpy(a->ast_childs + idx + 1, a->ast_childs + idx,
             ast_size * (a->ast_size - idx));
      a->ast_childs[idx] = b;
    }
  }

  a->ast_size += 1;
}

void ast_remove(ast *a, size_t idx) {
  ast *b = a->ast_childs[idx];

  ast_delete(b);

  if (idx != a->ast_size - 1) {
    memcpy(a->ast_childs + idx, a->ast_childs + idx + 1,
           sizeof(void (ast::*)()) * (a->ast_size - idx - 1));
  }

  a->ast_size -= 1;

  if (a->ast_size - a->ast_reserved_size > ast::childs_margin) {
    ast **childs = (ast **)malloc(sizeof(void (ast::*)()) *
                                  (a->ast_size + ast::childs_margin));

    memcpy(childs, a->ast_childs, sizeof(void (ast::*)()) * a->ast_size);

    free(a->ast_childs);

    a->ast_childs = childs;
  }
}

size_t ast_size(ast *ast) { return ast->ast_size; }

ast::kind ast_kind(ast *ast) { return ast->ast_kind; }

std::string ast_id(ast *ast) { return std::string(*ast->ast_id); }

Int ast_value(ast *ast) { return Int(*ast->ast_int_val); }

std::string ast_funname(ast *ast) { return std::string(*ast->ast_id); }

int order_relation(ast *a, ast *b) {
  if (ast_is_kind(a, ast::integer) && ast_is_kind(b, ast::integer)) {
    if (ast_value(a) == ast_value(b))
      return 2;

    return ast_value(a) > ast_value(b);
  }

  if (ast_is_kind(a, ast::fraction) && ast_is_kind(b, ast::fraction)) {
    Int na = ast_value(a->ast_childs[0]);
    Int da = ast_value(a->ast_childs[1]);
    Int nb = ast_value(b->ast_childs[0]);
    Int db = ast_value(b->ast_childs[1]);

    if (na == nb && da == db)
      return 2;

    return na * db > nb * da;
  }

  if (ast_is_kind(a, ast::integer) && ast_is_kind(b, ast::fraction)) {
    Int na = ast_value(a);
    Int nb = ast_value(b->ast_childs[0]);
    Int db = ast_value(b->ast_childs[1]);

		Int ct = na*db;

		if(ct == nb) return 2;

		return ct > nb;
  }

  if (ast_is_kind(a, ast::fraction) && ast_is_kind(b, ast::integer)) {
    Int nb = ast_value(b);
    Int na = ast_value(a->ast_childs[0]);
    Int da = ast_value(a->ast_childs[1]);

		Int ct = nb*da;

		if(ct == na) return 2;

		return na > ct;
  }

  if (ast_is_kind(a, ast::symbol) && ast_is_kind(b, ast::symbol)) {
    std::string id_a = ast_id(a);
    std::string id_b = ast_id(b);

    if (id_a == id_b)
      return 2;

    return !std::lexicographical_compare(
        id_a.c_str(), id_a.c_str() + id_a.length(), id_b.c_str(),
        id_b.c_str() + id_b.length());
  }

  if (ast_kind(a) == ast_kind(b) &&
      ast_is_kind(a, ast::infinity | ast::negative_infinity)) {
    return 2;
  }

  if (ast_is_kind(a, ast::infinity)) {
    return 0;
  }

  if (ast_is_kind(b, ast::infinity)) {
    return 1;
  }

  if (ast_is_kind(a, ast::negative_infinity)) {
    return 0;
  }

  if (ast_is_kind(b, ast::negative_infinity)) {
    return 1;
  }

  if (ast_is_kind(a, ast::add) && ast_is_kind(b, ast::add)) {

    long m = ast_size(a);
    long n = ast_size(b);

    long l = std::min(ast_size(a), ast_size(b));

    m = m - 1;
    n = n - 1;

    for (long i = 0; i < l; i++) {
      int t = order_relation(ast_operand(a, m - i), ast_operand(b, n - i));

      if (t != 2)
        return t;
    }

		if(m == n) return 2;
    return m > n;
  }

  if (ast_is_kind(a, ast::mul) && ast_is_kind(b, ast::mul)) {
    long m = ast_size(a);
    long n = ast_size(b);

    long l = std::min(ast_size(a), ast_size(b));

    m = m - 1;
    n = n - 1;

    for (long i = 0; i < l; i++) {
      int t = order_relation(ast_operand(a, m - i), ast_operand(b, n - i));
      if (t != 2)
        return t;
    }

		if(m == n) return 2;
    return m > n;
  }

  if (ast_is_kind(a, ast::integer | ast::fraction)) {
    if (ast_is_kind(b, ast::pow | ast::symbol)) {
      return 0;
    }

    return 1;
  }

  if (ast_is_kind(a, ast::pow) && ast_is_kind(b, ast::pow)) {
    int t = order_relation(ast_operand(a, 0), ast_operand(b, 0));

    if (t != 2)
      return t;

    return order_relation(ast_operand(a, 1), ast_operand(b, 1));
  }

  if (ast_is_kind(a, ast::fact) && ast_is_kind(b, ast::fact)) {
    return order_relation(ast_operand(a, 0), ast_operand(b, 0));
  }

  if (ast_is_kind(a, ast::funcall) && ast_is_kind(b, ast::funcall)) {
    std::string name_a = ast_funname(a);
    std::string name_b = ast_funname(b);

    if (name_a != name_b) {
      return !std::lexicographical_compare(
          name_a.c_str(), name_a.c_str() + name_a.length(), name_b.c_str(),
          name_b.c_str() + name_b.length());
    }

    size_t m = ast_size(a);
    size_t n = ast_size(b);

    size_t l = std::min(ast_size(a), ast_size(b));

    for (size_t i = 0; i < l; i++) {
      int t = order_relation(ast_operand(a, i), ast_operand(b, i));
      if (t != 2)
        return t;
    }

		if(m == n) return 2;
    return m > n;
  }

  if (ast_is_kind(a, ast::mul) &&
      ast_is_kind(b, ast::pow | ast::add | ast::fact | ast::funcall |
                         ast::symbol)) {
    int t = order_relation(ast_operand(a, 0), b);

    if (t == 2) {
      return ast_size(a) > 1;
    }

    return !t;
  }

  if (ast_is_kind(a, ast::pow) &&
      ast_is_kind(b, ast::add | ast::fact | ast::funcall | ast::symbol)) {
    int t = order_relation(ast_operand(a, 0), b);

    if (t == 2) {
      if (ast_is_kind(ast_operand(a, 1), ast::integer)) {
        return ast_value(ast_operand(a, 1)) > 1;
      }

      return 1;
    }

    return t;
  }

  if (ast_is_kind(a, ast::add) &&
      ast_is_kind(b, ast::fact | ast::funcall | ast::symbol)) {
    int t = order_relation(ast_operand(a, 0), b);

    if (t == 2) {
      return ast_size(a) > 1;
    }

    return t;
  }

  if (ast_is_kind(a, ast::fact) && ast_is_kind(b, ast::funcall | ast::symbol)) {
    return order_relation(ast_operand(a, 0), b);
  }

  if (ast_is_kind(a, ast::funcall) && ast_is_kind(b, ast::symbol)) {
    if (ast_funname(a) == ast_id(b))
      return 2;

    return 1;
  }

  return !order_relation(b, a);
}

long int ast_sort_split(ast *a, long l, long r) {
  long int i = l - 1;

  ast *p = a->ast_childs[r];

  for (long int j = l; j < r; j++) {
    if (order_relation(a->ast_childs[j], p) == 0) {
      i = i + 1;

      // swap i and j
      ast *t = a->ast_childs[i];

      a->ast_childs[i] = a->ast_childs[j];
      a->ast_childs[j] = t;
    }
  }

  ast *t = a->ast_childs[i + 1];

  a->ast_childs[i + 1] = a->ast_childs[r];
  a->ast_childs[r] = t;

  return i + 1;
}

void ast_sort_childs(ast *a, long int l, long int r) {
  if (l < r) {
    long int m = ast_sort_split(a, 0, r);

    ast_sort_childs(a, l, m - 1);
    ast_sort_childs(a, m + 1, r);
  }
}

void ast_sort(ast *a) {
  if (ast_is_kind(a, ast::integer | ast::fraction | ast::infinity |
                         ast::negative_infinity | ast::symbol | ast::fail |
                         ast::undefined))
    return;

  size_t i = ast_is_kind(a, ast::sub) ? 1 : 0;

  for (; i < a->ast_size; i++) {
    ast_sort(ast_operand(a, i));
  }

  if (ast_is_kind(a, ast::list | ast::pow | ast::div | ast::integral |
                         ast::derivative))
    return;

  ast_sort_childs(a, 0, ast_size(a) - 1);
}

std::string ast_to_string(ast *tree) {
  if (ast_is_kind(tree, ast::integer)) {
    return tree->ast_int_val->to_string();
  }

  if (ast_is_kind(tree, ast::symbol)) {
    return std::string(*tree->ast_id);
  }

  if (ast_is_kind(tree, ast::undefined)) {
    return "undefined";
  }

  if (ast_is_kind(tree, ast::fail)) {
    return "fail";
  }

  if (ast_is_kind(tree, ast::infinity)) {
    return "inf";
  }

  if (ast_is_kind(tree, ast::negative_infinity)) {
    return "-inf";
  }

  if (ast_is_kind(tree, ast::fraction)) {
    return ast_to_string(ast_operand(tree, 0)) + "/" +
           ast_to_string(ast_operand(tree, 1));
  }

  if (ast_is_kind(tree, ast::fraction)) {
    return "sqrt(" + ast_to_string(ast_operand(tree, 0)) + ")";
  }

  if (ast_is_kind(tree, ast::funcall)) {
    std::string r = ast_funname(tree) + "(";

    if (ast_size(tree) > 0) {
      for (size_t i = 0; i < ast_size(tree) - 1; i++) {
        r += ast_to_string(ast_operand(tree, i));
        r += ",";
      }

      r += ast_to_string(ast_operand(tree, ast_size(tree) - 1));
    }

    r += ")";

    return r;
  }

  if (ast_is_kind(tree, ast::pow)) {
    std::string r = "";

    if (ast_is_kind(ast_operand(tree, 0),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += "(";
    }

    r += ast_to_string(ast_operand(tree, 0));

    if (ast_is_kind(ast_operand(tree, 0),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += ")";
    }

    r += "^";

    if (ast_is_kind(ast_operand(tree, 1),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += "(";
    }

    r += ast_to_string(ast_operand(tree, 1));

    if (ast_is_kind(ast_operand(tree, 1),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += ")";
    }

    return r;
  }

  if (ast_is_kind(tree, ast::div)) {
    std::string r = "";

    if (ast_is_kind(ast_operand(tree, 0),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += "(";
    }

    r += ast_to_string(ast_operand(tree, 0));

    if (ast_is_kind(ast_operand(tree, 0),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += ")";
    }

    r += " ÷ ";

    if (ast_is_kind(ast_operand(tree, 1),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += "(";
    }

    r += ast_to_string(ast_operand(tree, 1));

    if (ast_is_kind(ast_operand(tree, 1),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += ")";
    }

    return r;
  }

  if (ast_is_kind(tree, ast::add)) {
    std::string r = "";

    for (size_t i = 0; i < ast_size(tree); i++) {
      if (ast_is_kind(ast_operand(tree, i), ast::sub | ast::add | ast::mul)) {
        r += "(";
      }

      r += ast_to_string(ast_operand(tree, i));

      if (ast_is_kind(ast_operand(tree, i), ast::sub | ast::add | ast::mul)) {
        r += ")";
      }

      if (i < ast_size(tree) - 1) {
        r += " + ";
      }
    }

    return r;
  }

  if (ast_is_kind(tree, ast::sub)) {
    std::string r = "";

    for (size_t i = 0; i < ast_size(tree) - 1; i++) {
      if (ast_is_kind(ast_operand(tree, i), ast::sub | ast::add | ast::mul)) {
        r += "(";
      }

      r += ast_to_string(ast_operand(tree, i));

      if (ast_is_kind(ast_operand(tree, i), ast::sub | ast::add | ast::mul)) {
        r += ")";
      }

      if (i != ast_size(tree) - 1) {
        r += " - ";
      }
    }

    return r;
  }

  if (ast_is_kind(tree, ast::mul)) {
    std::string r = "";

    for (size_t i = 0; i < ast_size(tree); i++) {
      if (ast_is_kind(ast_operand(tree, i), ast::sub | ast::add | ast::mul)) {
        r += "(";
      }

      r += ast_to_string(ast_operand(tree, i));

      if (ast_is_kind(ast_operand(tree, i), ast::sub | ast::add | ast::mul)) {
        r += ")";
      }

      if (i < ast_size(tree) - 1) {
        r += "⋅";
      }
    }

    return r;
  }

  return "to_string_not_implemented";
}


ast *eval_add_consts(ast *a, ast *b) {
  if (ast_is_kind(a, ast::integer) && ast_is_kind(b, ast::integer)) {
    return ast_integer(ast_value(a) + ast_value(b));
  }

  if (ast_is_kind(a, ast::fraction) && ast_is_kind(b, ast::fraction)) {
    Int num_a = ast_value(ast_operand(a, 0));
    Int den_a = ast_value(ast_operand(a, 1));
    Int num_b = ast_value(ast_operand(b, 0));
    Int den_b = ast_value(ast_operand(b, 1));

    Int num = num_a * den_b + num_b * den_a;
    Int den = den_b * den_a;

    Int cff = abs(gcd(num, den));

    if (den / cff == 1) {
      return ast_integer(num / cff);
    }

    return ast_create(ast::fraction,
                      {ast_integer(num / cff), ast_integer(den / cff)});
  }

  ast *i = ast_is_kind(a, ast::integer) ? a : b;
  ast *f = ast_is_kind(a, ast::integer) ? b : a;

  Int val = ast_value(i);
  Int num = ast_value(ast_operand(f, 0));
  Int den = ast_value(ast_operand(f, 1));

  num = val * den + num;

  Int cff = abs(gcd(num, den));

  if (den / cff == 1) {
    return ast_integer(num / cff);
  }

  return ast_create(ast::fraction,
                    {ast_integer(num / cff), ast_integer(den / cff)});
}

ast *eval_add_integer(ast *a, Int b) {
  if (ast_is_kind(a, ast::integer)) {
    return ast_integer(ast_value(a) + b);
  }

	if(ast_is_kind(a, ast::fraction)) {

  Int num = ast_value(ast_operand(a, 0));
  Int den = ast_value(ast_operand(a, 1));

  num = b * den + num;

  Int cff = abs(gcd(num, den));

  if (den / cff == 1) {
    return ast_integer(num / cff);
  }

  return ast_create(ast::fraction,
                    {ast_integer(num / cff), ast_integer(den / cff)});
	}

	return ast_create(ast::add, {ast_copy(a), ast_integer(b)});
}


ast* eval_add_multiplications(ast* a, ast* b) {
	long m = ast_size(a);
	long n = ast_size(b);

	long k = std::min(m, n);

	bool success = true;

	for(long i = 0; i < k; i++) {
		ast* lp = ast_operand(a, --m);
		ast* rp = ast_operand(b, --n);

		if (ast_is_kind(lp, ast::integer | ast::fraction) &&
				ast_is_kind(rp, ast::integer | ast::fraction)) {
			break;
		}

		if(ast_is_kind(rp, ast::integer | ast::fraction) || ast_is_kind(lp, ast::integer | ast::fraction)) {
			success = false;
			break;
		}

		if(order_relation(lp, rp) != 2) {
			success = false;
			break;
		}
	}

	if(!success) return nullptr;

}

ast *eval_sub_consts(ast *a, ast *b) {
  if (ast_is_kind(a, ast::integer) && ast_is_kind(b, ast::integer)) {
    return ast_integer(ast_value(a) - ast_value(b));
  }

  if (ast_is_kind(a, ast::fraction) && ast_is_kind(b, ast::fraction)) {
    Int num_a = ast_value(ast_operand(a, 0));
    Int den_a = ast_value(ast_operand(a, 1));
    Int num_b = ast_value(ast_operand(b, 0));
    Int den_b = ast_value(ast_operand(b, 1));

    Int num = num_a * den_b - num_b * den_a;
    Int den = den_b * den_a;

    Int cff = abs(gcd(num, den));

    if (den / cff == 1) {
      return ast_integer(num / cff);
    }

    return ast_create(ast::fraction,
                      {ast_integer(num / cff), ast_integer(den / cff)});
  }

  ast *i = ast_is_kind(a, ast::integer) ? a : b;
  ast *f = ast_is_kind(a, ast::integer) ? b : a;

  Int val = ast_value(i);
  Int num = ast_value(ast_operand(f, 0));
  Int den = ast_value(ast_operand(f, 1));

  num = val * den - num;

  Int cff = abs(gcd(num, den));

  if (den / cff == 1) {
    return ast_integer(num / cff);
  }

  return ast_create(ast::fraction,
                    {ast_integer(num / cff), ast_integer(den / cff)});
}

ast *eval_mul_consts(ast *a, ast *b) {
  if (ast_is_kind(a, ast::integer) && ast_is_kind(b, ast::integer)) {
    return ast_integer(ast_value(a) * ast_value(b));
  }

  if (ast_is_kind(a, ast::fraction) && ast_is_kind(b, ast::fraction)) {
    Int num_a = ast_value(ast_operand(a, 0));
    Int den_a = ast_value(ast_operand(a, 1));
    Int num_b = ast_value(ast_operand(b, 0));
    Int den_b = ast_value(ast_operand(b, 1));

    Int num = num_a * num_b;
    Int den = den_b * den_a;

    Int cff = abs(gcd(num, den));

    if (den / cff == 1) {
      return ast_integer(num / cff);
    }

    return ast_create(ast::fraction,
                      {ast_integer(num / cff), ast_integer(den / cff)});
  }

  ast *i = ast_is_kind(a, ast::integer) ? a : b;
  ast *f = ast_is_kind(a, ast::integer) ? b : a;

  Int val = ast_value(i);
  Int num = ast_value(ast_operand(f, 0));
  Int den = ast_value(ast_operand(f, 1));

  num = val * num;

  Int cff = abs(gcd(num, den));

  if (den / cff == 1) {
    return ast_integer(num / cff);
  }

  return ast_create(ast::fraction,
                    {ast_integer(num / cff), ast_integer(den / cff)});
}

ast *eval_div_consts(ast *a, ast *b) {
  if (ast_is_kind(a, ast::integer) && ast_is_kind(b, ast::integer)) {
    return ast_integer(ast_value(a) / ast_value(b));
  }

  if (ast_is_kind(a, ast::fraction) && ast_is_kind(b, ast::fraction)) {
    Int num_a = ast_value(ast_operand(a, 0));
    Int den_a = ast_value(ast_operand(a, 1));
    Int num_b = ast_value(ast_operand(b, 0));
    Int den_b = ast_value(ast_operand(b, 1));

    Int num = num_a * den_b;
    Int den = den_b * num_a;

    Int cff = abs(gcd(num, den));

    if (den / cff == 1) {
      return ast_integer(num / cff);
    }

    return ast_create(ast::fraction,
                      {ast_integer(num / cff), ast_integer(den / cff)});
  }

  ast *i = ast_is_kind(a, ast::integer) ? a : b;
  ast *f = ast_is_kind(a, ast::integer) ? b : a;

  Int val = ast_value(i);
  Int num = ast_value(ast_operand(f, 0));
  Int den = ast_value(ast_operand(f, 1));

  Int n = val * den;

  Int cff = abs(gcd(n, den));

  if (num / cff == 1) {
    return ast_integer(n / cff);
  }

  return ast_create(ast::fraction,
                    {ast_integer(n / cff), ast_integer(num / cff)});
}

ast *eval_sqrt(ast *a) {
  return ast_create(ast::pow, {ast_operand(a, 0), ast_fraction(1, 2)});
}


ast *eval_pow_int_exp(ast *b, Int e) {
  if (ast_is_kind(b, ast::infinity | ast::negative_infinity | ast::undefined |
                         ast::fail)) {
    return ast_copy(b);
  }

  if (ast_is_kind(b, ast::integer) && ast_value(b) == 0) {
    if (e < 0) {
      return ast_create(ast::undefined);
    }

    return ast_integer(0);
  }

  if (e == 0) {
    return ast_integer(1);
  }

  if (e == 1) {
    return ast_copy(b);
  }

  if (e < 0) {

    if (ast_is_kind(b, ast::integer)) {
      return ast_fraction(1, pow(ast_value(b), abs(e)));
    }

    if (ast_is_kind(b, ast::fraction)) {
      return ast_fraction(pow(ast_value(ast_operand(b, 1)), abs(e)),
                          pow(ast_value(ast_operand(b, 0)), abs(e)));
    }
  }

  if (ast_is_kind(b, ast::integer)) {
    return ast_integer(pow(ast_value(b), abs(e)));
  }

  if (ast_is_kind(b, ast::fraction)) {
    return ast_fraction(pow(ast_value(ast_operand(b, 0)), abs(e)),
                        pow(ast_value(ast_operand(b, 1)), abs(e)));
  }

  return ast_create(ast::pow, {ast_copy(b), ast_integer(e)});
}



ast *eval_pow(ast *a) {
  ast *b = ast_operand(a, 0);
  ast *e = ast_operand(a, 1);

  if (ast_is_kind(b, ast::infinity | ast::negative_infinity | ast::undefined |
									ast::fail)) {
    return ast_copy(b);
	}

	if(ast_is_kind(b, ast::integer) && ast_value(b) == 0) {
		if(ast_is_kind(e, ast::integer) && ast_value(e) < 0) {
			return ast_create(ast::undefined);
		}

		return ast_integer(0);
	}

  if (ast_is_kind(e, ast::integer)) {
		return eval_pow_int_exp(b, ast_value(e));
  }

  return ast_create(ast::pow, {ast_copy(b), ast_copy(e)});
}

ast* eval_mul_binary(ast* a, ast* b) {
	// TODO: implement
}


ast *eval_div(ast *a) {
	ast* b = eval_pow_int_exp(ast_operand(a, 1), -1);
	ast* c = eval_mul_binary(ast_operand(a, 0), b);

	ast_delete(b);

	return c;
}

ast *eval_add(ast *a) {
	// TODO: implement
}
ast* eval_mul(ast* a) {
	// TODO: implement
}

ast *eval(ast *a) {}

} // namespace ast_teste
