#include "AST3.hpp"
#include "Core/AST/Integer.hpp"

#include <algorithm>
#include <cmath>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <initializer_list>
#include <math.h>
#include <random>
#include <string>

namespace ast_teste {

void ast_allocate_operands(ast* a, size_t s) {
	a->ast_childs = (ast**)calloc(sizeof(void (ast::*)()), s);
	a->ast_reserved_size = s;
	a->size_of = s;
}

ast *create(ast::kind kind, size_t reserve) {
  ast *a = (ast *)malloc(sizeof(ast));

  a->ref_count = 1;

  a->kind_of = kind;

  a->ast_childs = (ast **)(calloc(sizeof(void (ast::*)()), reserve));

  a->ast_format = ast::default_format;

  a->size_of = 0;

  a->ast_reserved_size = reserve;

  return a;
}

ast *create(ast::kind kind) {
  ast *a = (ast *)malloc(sizeof(ast));

  a->ref_count = 1;

  a->kind_of = kind;

  a->ast_childs =
      (ast **)(calloc(sizeof(void (ast::*)()), ast::childs_margin + 1));

  a->ast_format = ast::default_format;

  a->size_of = 0;

  a->ast_reserved_size = ast::childs_margin + 1;

  return a;
}

ast *create(ast::kind kind, std::initializer_list<ast *> l) {
  ast *a = (ast *)malloc(sizeof(ast));

  a->ref_count = 1;

  a->kind_of = kind;

  a->ast_format = ast::default_format;

  a->size_of = l.size();

  a->ast_reserved_size = a->size_of;

  a->ast_childs = (ast **)(malloc(sizeof(void (ast::*)()) * l.size()));

  memcpy(a->ast_childs, l.begin(), (size_t)l.end() - (size_t)l.begin());

  return a;
}

void ast_set_kind(ast *a, ast::kind kind) { a->kind_of = kind; }

ast *ast_set_operand(ast *a, ast *v, size_t i) {
  a->ast_childs[i] = v;
  return v;
}

void ast_set_size(ast *a, size_t s) {
  assert(a->ast_reserved_size >= s);
  a->size_of = s;
}

void ast_delete_operands(ast *a) {
  if (a == 0)
    return;

  for (size_t i = 0; i < size_of(a); i++) {
    ast_delete(operand(a, i));
  }

  if (a->ast_childs) {
    free(a->ast_childs);
  }

  a->size_of = 0;
  a->ast_reserved_size = 0;
  a->ast_childs = 0;
}

void ast_delete_metadata(ast *a) {
  if (is(a, ast::symbol)) {
    free(a->ast_sym);
  }

  if (is(a, ast::integer)) {
    delete a->ast_int;
  }
}

void ast_delete(ast *a) {
  if (a == 0)
    return;

  a = ast_dec_ref(a);

  if (a->ref_count > 0)
    return;

  ast_delete_operands(a);
  ast_delete_metadata(a);

  free(a);
}

ast *symbol(const char *id) {
  ast *a = create(ast::symbol);

  a->ast_sym = strdup(id);

  return a;
}

ast *integer(Int value) {
  ast *a = create(ast::integer);

  a->ast_int = new Int(value);

  return a;
}

ast *fraction(Int num, Int den) {
  return create(ast::fraction, {integer(num), integer(den)});
}

inline ast *ast_modifiable_ref(ast *a) {
  return a->ref_count > 1 ? ast_copy(a) : a;
}

inline void ast_assign_modifiable_ref(ast *a, ast **b) {
  ast *t = ast_modifiable_ref(a);

  if (t != a)
    ast_dec_ref(a);

  *b = t;
}

inline void ast_assign(ast** b, ast* a) {
	if(*b) ast_delete(*b);
	*b = a;
}

void insert(ast *a, ast *b, size_t idx) {
  assert(a->size_of >= idx);

  const size_t size_of = sizeof(void (ast::*)());

  if (a->ast_reserved_size == a->size_of) {

    ast **childs = (ast **)calloc(size_of, (a->size_of + ast::childs_margin));

    a->ast_reserved_size = a->size_of + ast::childs_margin;

    memcpy(childs, a->ast_childs, size_of * idx);

    childs[idx] = b;

    memcpy(childs + idx + 1, a->ast_childs + idx,
           size_of * (a->size_of - idx));

    free(a->ast_childs);

    a->ast_childs = childs;
  } else {
    if (idx == a->size_of) {
      a->ast_childs[idx] = b;
    } else {
      memcpy(a->ast_childs + idx + 1, a->ast_childs + idx,
             size_of * (a->size_of - idx));
      a->ast_childs[idx] = b;
    }
  }

  a->size_of += 1;
}

void remove(ast *a, size_t idx) {
  if (operand(a, idx)) {
    ast_delete(operand(a, idx));
  }

  if (idx != a->size_of - 1) {
    memcpy(a->ast_childs + idx, a->ast_childs + idx + 1,
           sizeof(void (ast::*)()) * (a->size_of - idx - 1));
  }

  a->size_of -= 1;

  if (a->size_of - a->ast_reserved_size > ast::childs_margin) {
    ast **childs = (ast **)calloc(sizeof(void (ast::*)()),
                                  (a->size_of + ast::childs_margin));

    memcpy(childs, a->ast_childs, sizeof(void (ast::*)()) * a->size_of);

    free(a->ast_childs);

    a->ast_childs = childs;
  }
}

int compare_consts(ast *a, ast *b) {
  assert(is(a, ast::constant) && is(b, ast::constant));

  if (is(a, ast::integer) && is(b, ast::integer)) {
    if (get_val(a) == get_val(b)) {
      return 0;
    }

    return get_val(a) > get_val(b) ? 1 : -1;
  }

  if (is(a, ast::fraction) && is(b, ast::fraction)) {
    Int na = get_val(a->ast_childs[0]);
    Int da = get_val(a->ast_childs[1]);
    Int nb = get_val(b->ast_childs[0]);
    Int db = get_val(b->ast_childs[1]);

    if (na * db == nb * da)
      return 0;

    return na * db - nb * da > 0 ? 1 : -1;
  }

  if (is(a, ast::integer) && is(b, ast::fraction)) {
    Int na = get_val(a);
    Int nb = get_val(b->ast_childs[0]);
    Int db = get_val(b->ast_childs[1]);

    Int ct = na * db;

    if (ct == nb) {
      return 0;
    }

    return ct > nb ? 1 : -1;
  }

  Int nb = get_val(b);
  Int na = get_val(a->ast_childs[0]);
  Int da = get_val(a->ast_childs[1]);

  Int ct = nb * da;

  if (ct == na) {
    return 0;
  }

  return na > ct ? 1 : -1;
}

bool should_revert_idx(ast::kind ctx) { return ctx & (ast::add); }

bool ast_is_zero(ast *a) {
  return (a == nullptr) || (is(a, ast::integer) && get_val(a) == 0);
}

inline int ast_op_cmp(ast *a, ast *b, ast::kind ctx) {
  long m = size_of(a);
  long n = size_of(b);

  long l = std::min(size_of(a), size_of(b));

  m = m - 1;
  n = n - 1;

  if (is(a, ast::constant) && is(b, ast::constant)) {
    return compare_consts(a, b);
  }

  if (ctx == ast::add) {

    if (is(a, ast::mul) && is(b, ast::mul)) {

      if (std::abs(m - n) > 1) {
        return n - m;
      }

      for (long i = 0; i < l; i++) {
        int order =
            kind_of(operand(a, m - i)) - kind_of(operand(b, n - i));

        if (order)
          return order;
      }

      for (long i = 0; i < l; i++) {
        int order = compare(operand(a, m - i), operand(b, n - i), ctx);

        if (order)
          return order;
      }
    }
  }

  for (long i = 0; i < l; i++) {
    int order =
        kind_of(operand(b, n - i)) - kind_of(operand(a, m - i));

    if (order)
      return order;
  }

  for (long i = 0; i < l; i++) {
    int order = compare(operand(a, m - i), operand(b, n - i), ctx);

    if (order)
      return order;
  }

  return (ctx & ast::add) ? m - n : n - m;
}

inline int compare_idents(ast *a, ast *b) {
  return strcmp(get_id(a), get_id(b));
}

std::string to_string(ast *tree) {
  if (!tree)
    return "null";

  if (is(tree, ast::integer)) {
    return tree->ast_int->to_string();
  }

  if (is(tree, ast::symbol)) {
    return std::string(tree->ast_sym);
  }

  if (is(tree, ast::undefined)) {
    return "undefined";
  }

  if (is(tree, ast::fail)) {
    return "fail";
  }

  if (is(tree, ast::infinity)) {
    return "inf";
  }

  if (is(tree, ast::negative_infinity)) {
    return "-inf";
  }

  if (is(tree, ast::fraction)) {
    return to_string(operand(tree, 0)) + "/" +
           to_string(operand(tree, 1));
  }

  if (is(tree, ast::fraction)) {
    return "sqrt(" + to_string(operand(tree, 0)) + ")";
  }

  if (is(tree, ast::funcall)) {
    std::string r = std::string(get_func_id(tree)) + "(";

    if (size_of(tree) > 0) {
      for (size_t i = 0; i < size_of(tree) - 1; i++) {
        r += to_string(operand(tree, i));
        r += ",";
      }

      r += to_string(operand(tree, size_of(tree) - 1));
    }

    r += ")";

    return r;
  }

  if (is(tree, ast::pow)) {
    std::string r = "";

    if (operand(tree, 0) &&
        is(operand(tree, 0),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += "(";
    }

    r += to_string(operand(tree, 0));

    if (operand(tree, 0) &&
        is(operand(tree, 0),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += ")";
    }

    r += "^";

    if (operand(tree, 1) &&
        is(operand(tree, 1),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += "(";
    }

    r += to_string(operand(tree, 1));

    if (operand(tree, 1) &&
        is(operand(tree, 1),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += ")";
    }

    return r;
  }

  if (is(tree, ast::div)) {
    std::string r = "";

    if (is(operand(tree, 0),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += "(";
    }

    r += to_string(operand(tree, 0));

    if (is(operand(tree, 0),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += ")";
    }

    r += " รท ";

    if (is(operand(tree, 1),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += "(";
    }

    r += to_string(operand(tree, 1));

    if (is(operand(tree, 1),
                    ast::sub | ast::add | ast::mul | ast::div)) {
      r += ")";
    }

    return r;
  }

  if (is(tree, ast::add)) {
    std::string r = "";

    for (size_t i = 0; i < size_of(tree); i++) {
      if (operand(tree, i) &&
          is(operand(tree, i), ast::sub | ast::add | ast::mul)) {

        r += "(";
      }

      r += to_string(operand(tree, i));

      if (operand(tree, i) &&
          is(operand(tree, i), ast::sub | ast::add | ast::mul)) {
        r += ")";
      }

      if (i < size_of(tree) - 1) {
        r += " + ";
      }
    }

    return r;
  }

  if (is(tree, ast::sub)) {
    std::string r = "";

    for (size_t i = 0; i < size_of(tree) - 1; i++) {
      if (operand(tree, i) &&
          is(operand(tree, i), ast::sub | ast::add | ast::mul)) {
        r += "(";
      }

      r += to_string(operand(tree, i));

      if (operand(tree, i) &&
          is(operand(tree, i), ast::sub | ast::add | ast::mul)) {
        r += ")";
      }

      if (i != size_of(tree) - 1) {
        r += " - ";
      }
    }

    return r;
  }

  if (is(tree, ast::mul)) {
    std::string r = "";

    for (size_t i = 0; i < size_of(tree); i++) {

      if (operand(tree, i) == nullptr) {
        continue;
      }

      if (is(operand(tree, i), ast::sub | ast::add | ast::mul)) {
        r += "(";
      }

      r += to_string(operand(tree, i));

      if (is(operand(tree, i), ast::sub | ast::add | ast::mul)) {
        r += ")";
      }

      if (i < size_of(tree) - 1) {
        r += "โ";
      }
    }

    return r;
  }

  if (is(tree, ast::fact)) {
    return to_string(operand(tree, 0)) + "!";
  }

  return "to_string_not_implemented";
}

std::string kind_of_id(ast *a) {
  switch (kind_of(a)) {

  case ast::integer: {
    return "integer";
  }
  case ast::symbol: {
    return "symbol";
  }
  case ast::funcall: {
    return "funcall";
  }
  case ast::fact: {
    return "fact";
  }
  case ast::pow: {
    return "pow";
  }
  case ast::mul: {
    return "mul";
  }
  case ast::add: {
    return "add";
  }
  case ast::sub: {
    return "div";
  }
  case ast::sqrt: {
    return "sqrt";
  }
  case ast::infinity: {
    return "infinity";
  }
  case ast::negative_infinity: {
    return "negative infinity";
  }

  case ast::undefined: {
    return "undefined";
  }

  case ast::fail: {
    return "fail";
  }

  case ast::fraction: {
    return "fraction";
  }

  case ast::div: {
    return "div";
  }

  default:
    return "";
  }
}

void ast_print(ast *a, int tabs) {
  printf("%*c<ast ", tabs, ' ');
  printf("ref_count=\"%lli\" ", a->ref_count);
  printf("address=\"%p\" ", a);
  printf("kind=\"%s\"", kind_of_id(a).c_str());

  if (kind_of(a) == ast::integer) {
    printf(" value=\"%s\"", get_val(a).to_string().c_str());
  }

  if (kind_of(a) == ast::symbol) {
    printf(" id=\"%s\"", get_id(a));
  }

  if (size_of(a)) {
    printf(">\n");
    // printf("\n%*c  childs: [\n", tabs, ' ');

    for (size_t i = 0; i < size_of(a); i++) {
      ast_print(operand(a, i), tabs + 3);
    }
    // printf("%*c  ];", tabs, ' ');
    printf("%*c</ast>\n", tabs, ' ');
  } else {
    printf(">\n");
  }
}

int compare(ast *a, ast *b, ast::kind ctx) {
  if (a == b)
    return 0;

  if (ctx & ast::mul) {
    if (is(a, ast::constant)) {
      return -1;
    }

    if (is(b, ast::constant)) {
      return +1;
    }

    if (is(a, ast::pow) && is(b, ast::pow)) {
      return compare(operand(a, 0), operand(b, 0), ctx);
    }

    // if(is(a, ast::add) && is(b, ast::pow)) {
    // 	int order = compare(a, operand(b, 0), ast::mul);

    // 	if(order == 0) {
    // 		return should_revert_idx(ctx)
    // 			? kind_of(a) - kind_of(b)
    // 			: kind_of(b) - kind_of(a);
    // 	}

    // 	return order;
    // }

    // if(is(b, ast::add) && is(a, ast::pow)) {
    // 	int order = compare(operand(a, 0), b, ast::mul);

    // 	if(order == 0) {

    // 		return should_revert_idx(ctx)
    // 			? kind_of(a) - kind_of(b)
    // 			: kind_of(b) - kind_of(a);
    // 	}

    // 	return order;
    // 	// if(compare(operand(a, 0), b, ast::mul) == 0) {
    // 	// 	return 0;
    // 	// return should_revert_idx(ctx)
    // 	// 	? kind_of(a) - kind_of(b)
    // 	// 	: kind_of(b) - kind_of(a);
    // 	// }
    // }

    if (is(a, ast::symbol | ast::add) && is(b, ast::pow)) {

      int order = compare(a, operand(b, 0), ast::mul);

      if (order == 0) {
        return kind_of(a) - kind_of(b);
      }

      return order;
    }

    if (is(b, ast::symbol | ast::add) && is(a, ast::pow)) {
      int order = compare(operand(a, 0), b, ast::mul);

      if (order == 0) {
        return kind_of(a) - kind_of(b);
      }

      return order;
    }

    if (is(a, ast::funcall) && is(b, ast::funcall)) {
      return strcmp(get_func_id(a), get_func_id(b));
    }

    if (is(a, ast::pow) && is(b, ast::funcall)) {
      return compare(operand(a, 0), b, ast::mul);
    }

    if (is(b, ast::pow) && is(a, ast::funcall)) {
      return compare(b, operand(a, 0), ast::mul);
    }

    if (is(a, ast::mul) &&
        is(b, ast::pow | ast::symbol | ast::funcall)) {
      long k = size_of(a);

      for (long i = k - 1; i >= 0; i--) {
        int order = compare(operand(a, i), b, ast::mul);

        if (order == 0) {
          return 0;
        }

        if (order < 0)
          break;
      }

      return +k - 1;
    }

    if (is(b, ast::mul) &&
        is(a, ast::pow | ast::symbol | ast::funcall)) {
      long k = size_of(b);

      for (long i = k - 1; i >= 0; i--) {
        int order = compare(operand(b, i), a, ast::mul);

        if (order == 0) {
          return 0;
        }

        if (order < 0)
          break;
      }

      return -k + 1;
    }
  }

  if (ctx & ast::add) {

    if (is(a, ast::constant) && is(b, ast::constant)) {
      return compare_consts(b, a);
    }

    if (is(a, ast::constant)) {
      return +1;
    }

    if (is(b, ast::constant)) {
      return -1;
    }

    if (is(a, ast::pow) && is(b, ast::pow)) {
      int i = compare(operand(a, 1), operand(b, 1), ctx);

      if (i != 0) {
        return i;
      }

      return compare(operand(a, 0), operand(b, 0), ctx);
    }

    if (is(a, ast::funcall) && is(b, ast::funcall)) {
      return strcmp(get_func_id(a), get_func_id(b));
    }

    if (is(a, ast::add) && is(b, ast::symbol)) {
      return +1;
    }

    if (is(a, ast::symbol) && is(b, ast::add)) {
      return -1;
    }

    if (is(a, ast::mul) && is(b, ast::symbol)) {
      long k = size_of(a);

      if (k > 2)
        return -k;

      int order = compare(operand(a, size_of(a) - 1), b, ctx);

      if (order == 0) {
        return -1;
      }

      return k > 2 ? -1 : order;
    }

    if (is(b, ast::mul) && is(a, ast::symbol)) {
      long k = size_of(b);

      if (k > 2) {
        return +k;
      }

      int order = compare(a, operand(b, size_of(b) - 1), ctx);

      if (order == 0) {
        return +1;
      }

      return k > 2 ? +1 : order;
    }

    if (is(a, ast::mul) && is(b, ast::pow)) {
      long k = size_of(a);

      if (k > 2)
        return -k;

      int order = compare(operand(a, 0), b, ctx);

      if (order == 0)
        return -1;

      return k > 2 ? -1 : order;
    }

    if (is(b, ast::mul) && is(a, ast::pow)) {
      long k = size_of(b);

      if (k > 2)
        return +k;

      int order = compare(a, operand(b, 0), ctx);

      if (order == 0)
        return +1;

      return k > 2 ? +1 : order;
    }
  }

  if (is(a, ast::funcall) && is(b, ast::funcall)) {
    return strcmp(get_func_id(a), get_func_id(b));
  }

  if (is(a, ast::constant) && is(b, ast::constant)) {
    return compare_consts(a, b);
  }

  if (is(a, ast::symbol) && is(b, ast::symbol)) {
    return compare_idents(a, b);
  }

  if (is(a, ast::add) && is(b, ast::add)) {
    return ast_op_cmp(a, b, ctx);
  }

  if (is(a, ast::mul) && is(b, ast::mul)) {
    return ast_op_cmp(a, b, ctx);
  }

  if (is(a, ast::pow) && is(b, ast::pow)) {
    return compare(operand(a, 0), operand(b, 0), ctx) ||
           compare(operand(a, 1), operand(b, 1), ctx);
  }

  if (is(a, ast::div) && is(b, ast::div)) {
    return compare(operand(a, 0), operand(b, 0), ctx) ||
           compare(operand(a, 1), operand(b, 1), ctx);
  }

  return should_revert_idx(ctx) ? kind_of(a) - kind_of(b)
                                : kind_of(b) - kind_of(a);
}

long int sort_split(ast *a, long l, long r) {
  long int i = l - 1;

  ast *p = a->ast_childs[r];

  for (long int j = l; j < r; j++) {
    if (compare(a->ast_childs[j], p, kind_of(a)) < 0) {
      i = i + 1;

      // swap i and j
      ast *t = a->ast_childs[i];

      a->ast_childs[i] = a->ast_childs[j];
      a->ast_childs[j] = t;
    }
  }

  ast *t = a->ast_childs[i + 1];

  a->ast_childs[i + 1] = a->ast_childs[r];
  a->ast_childs[r] = t;

  return i + 1;
}

ast *sort_childs(ast *a, long int l, long int r) {
  ast_assign_modifiable_ref(a, &a);

  if (l < r) {
    long int m = sort_split(a, l, r);

    a = sort_childs(a, l, m - 1);
    a = sort_childs(a, m + 1, r);
  }

  return a;
}

ast *sort(ast *a) {
  ast_assign_modifiable_ref(a, &a);

  if (is(a, ast::terminal)) {
    return a;
  }

  size_t i = is(a, ast::sub) ? 1 : 0;

  for (; i < a->size_of; i++) {
    a = sort(operand(a, i));
  }

  if (is(a, ast::ordered)) {
    return a;
  }

  a = sort_childs(a, 0, size_of(a) - 1);

  return a;
}

ast *ast_copy(ast *a) {
  ast *b = (ast *)calloc(sizeof(ast), 1);

  b->ref_count = 1;

  b->kind_of = a->kind_of;
  b->size_of = a->size_of;
  b->ast_reserved_size = a->ast_reserved_size;
  b->ast_format = a->ast_format;

  if (is(a, ast::integer)) {
    b->ast_int = new Int(*a->ast_int);
    return b;
  }

  if (is(a, ast::symbol)) {
    b->ast_sym = strdup(a->ast_sym);
    return b;
  }

  b->ast_childs = (ast **)calloc(sizeof(void (ast::*)()), b->ast_reserved_size);

  for (size_t i = 0; i < size_of(a); i++) {
    b->ast_childs[i] = ast_inc_ref(operand(a, i));
  }

  return b;
}

inline ast *ast_set_to_undefined(ast *a) {
  ast_assign_modifiable_ref(a, &a);

  ast_delete_operands(a);
  ast_delete_metadata(a);

  ast_set_kind(a, ast::undefined);

  return a;
}

inline ast *ast_set_to_fail(ast *a) {
  ast_assign_modifiable_ref(a, &a);

  ast_delete_operands(a);
  ast_delete_metadata(a);

  ast_set_kind(a, ast::fail);

  return a;
}

inline ast *ast_set_to_int(ast *a, Int v) {
  ast_assign_modifiable_ref(a, &a);

  ast_delete_operands(a);
  ast_delete_metadata(a);

  ast_set_kind(a, ast::integer);

  a->ast_int = new Int(v);

  return a;
}

inline ast *ast_replace_operand(ast *a, ast *v, size_t i) {
  ast_assign_modifiable_ref(a, &a);

  ast_set_operand(a, v, i);

  return a;
}

inline ast *ast_set_op_to_int(ast *a, size_t i, Int v) {
  ast_assign_modifiable_ref(a, &a);

  ast *t = operand(a, i);

  t = ast_set_to_int(t, v);

  return ast_replace_operand(a, t, i);
}

inline ast *ast_set_to_fra(ast *a, Int u, Int v) {
  ast_assign_modifiable_ref(a, &a);

  ast_delete_operands(a);
  ast_delete_metadata(a);

  ast_set_kind(a, ast::fraction);

  insert(a, integer(u), 0);
  insert(a, integer(v), 1);

  return a;
}

inline ast *ast_set_op_to_fra(ast *a, size_t i, Int u, Int v) {
  ast_assign_modifiable_ref(a, &a);

  ast *t = operand(a, i);

  t = ast_set_to_fra(t, u, v);

  return ast_replace_operand(a, t, i);
}

inline ast *ast_set_to_sym(ast *a, const char *s) {
  ast_assign_modifiable_ref(a, &a);

  ast_delete_operands(a);

  ast_delete_metadata(a);

  ast_set_kind(a, ast::symbol);

  a->ast_sym = strdup(s);

  return a;
}

inline ast *ast_set_op_to_sym(ast *a, size_t i, const char *s) {
  ast_assign_modifiable_ref(a, &a);

  ast *t = operand(a, i);

  t = ast_set_to_sym(t, s);

  return ast_replace_operand(a, t, i);
}

// a = a + b
inline ast *ast_set_inplace_add_consts(ast *a, ast *b) {
  assert(is(a, ast::constant));
  assert(is(b, ast::constant));

  ast_assign_modifiable_ref(a, &a);

  if (is(a, ast::integer) && is(b, ast::integer)) {
    Int x = get_val(a);
    Int y = get_val(b);

    return ast_set_to_int(a, x + y);
  }

  if (is(a, ast::fraction) && is(b, ast::fraction)) {
    Int x = get_val(operand(a, 0));
    Int y = get_val(operand(a, 1));
    Int w = get_val(operand(b, 0));
    Int z = get_val(operand(b, 1));

    Int e = x * z + w * y;
    Int k = y * z;

    if (e % k == 0) {
      a = ast_set_to_int(a, e / k);
    } else {

      Int g = abs(gcd(e, k));

      a = ast_set_to_fra(a, e / g, k / g);
    }

    return a;
  }

  if (is(a, ast::fraction) && is(b, ast::integer)) {
    Int x = get_val(operand(a, 0));
    Int y = get_val(operand(a, 1));
    Int w = get_val(b);

    Int e = x + w * y;
    Int k = y;

    if (e % k == 0) {
      a = ast_set_to_int(a, e / k);
    } else {

      Int g = abs(gcd(e, k));

      a = ast_set_to_fra(a, e / g, k / g);
    }

    return a;
  }

  if (is(b, ast::fraction) && is(a, ast::integer)) {
    Int x = get_val(operand(b, 0));
    Int y = get_val(operand(b, 1));
    Int w = get_val(a);

    Int e = x + w * y;
    Int k = y;

    if (e % k == 0) {
      a = ast_set_to_int(a, e / k);
    } else {

      Int g = abs(gcd(e, k));

      a = ast_set_to_fra(a, e / g, k / g);
    }

    return a;
  }

  return a;
}

inline ast *ast_set_inplace_add_consts(ast *a, Int b) {
  assert(is(a, ast::constant));
  ast_assign_modifiable_ref(a, &a);

  if (is(a, ast::integer)) {
    Int x = get_val(a);

    return ast_set_to_int(a, x + b);
  }

  if (is(a, ast::fraction)) {
    Int x = get_val(operand(a, 0));
    Int y = get_val(operand(a, 1));

    Int e = x + b * y;

    if (e % y == 0) {
      a = ast_set_to_int(a, e / y);
    } else {

      Int g = abs(gcd(e, y));

      a = ast_set_to_fra(a, e / g, y / g);
    }

    return a;
  }

  return a;
}

inline ast *ast_set_op_inplace_add_consts(ast *a, size_t i, ast *b) {
  ast_assign_modifiable_ref(a, &a);

  ast *t = operand(a, i);

  t = ast_set_inplace_add_consts(t, b);

  return ast_replace_operand(a, t, i);
}

inline ast *ast_set_op_inplace_add_consts(ast *a, size_t i, Int b) {
  ast_assign_modifiable_ref(a, &a);

  ast *t = operand(a, i);

  t = ast_set_inplace_add_consts(t, b);

  return ast_replace_operand(a, t, i);
}

inline ast *ast_set_inplace_mul_consts(ast *a, ast *b) {
  assert(is(a, ast::constant));
  assert(is(b, ast::constant));

  ast_assign_modifiable_ref(a, &a);

  if (is(a, ast::integer) && is(b, ast::integer)) {
    Int x = get_val(a);
    Int y = get_val(b);

    return ast_set_to_int(a, x * y);
  }

  if (is(a, ast::fraction) && is(b, ast::fraction)) {
    Int x = get_val(operand(a, 0));
    Int y = get_val(operand(a, 1));
    Int w = get_val(operand(b, 0));
    Int z = get_val(operand(b, 1));

    Int e = x * w;
    Int k = y * z;

    if (e % k == 0) {
      a = ast_set_to_int(a, e / k);
    } else {

      Int g = abs(gcd(e, k));

      a = ast_set_to_fra(a, e / g, k / g);
    }

    return a;
  }

  if (is(a, ast::fraction) && is(b, ast::integer)) {
    Int x = get_val(operand(a, 0));
    Int y = get_val(operand(a, 1));
    Int w = get_val(b);

    Int e = x * w;
    Int k = y;

    if (e % k == 0) {
      a = ast_set_to_int(a, e / k);
    } else {

      Int g = abs(gcd(e, k));

      a = ast_set_to_fra(a, e / g, k / g);
    }

    return a;
  }

  if (is(b, ast::fraction) && is(a, ast::integer)) {
    Int x = get_val(operand(b, 0));
    Int y = get_val(operand(b, 1));
    Int w = get_val(a);

    Int e = x * w;
    Int k = y;

    if (e % k == 0) {
      a = ast_set_to_int(a, e / k);
    } else {

      Int g = abs(gcd(e, k));

      a = ast_set_to_fra(a, e / g, k / g);
    }

    return a;
  }

  return a;
}

inline ast *ast_set_inplace_mul_consts(ast *a, Int b) {
  assert(is(a, ast::constant));

  ast_assign_modifiable_ref(a, &a);

  if (is(a, ast::integer)) {
    Int x = get_val(a);

    return ast_set_to_int(a, x * b);
  }

  if (is(a, ast::fraction)) {
    Int x = get_val(operand(a, 0));
    Int y = get_val(operand(a, 1));

    Int e = x * b;

    if (e % y == 0) {
      a = ast_set_to_int(a, e / y);
    } else {

      Int g = abs(gcd(e, y));

      a = ast_set_to_fra(a, e / g, y / g);
    }

    return a;
  }
  return a;
}

inline ast *ast_set_op_inplace_mul_consts(ast *a, size_t i, ast *b) {
  ast_assign_modifiable_ref(a, &a);

  ast *t = operand(a, i);

  t = ast_set_inplace_mul_consts(t, b);

  return ast_replace_operand(a, t, i);
}

inline ast *ast_set_op_inplace_mul_consts(ast *a, size_t i, Int b) {
  ast_assign_modifiable_ref(a, &a);

  ast *t = operand(a, i);

  t = ast_set_inplace_mul_consts(t, b);

  return ast_replace_operand(a, t, i);
}

inline ast *ast_set_to_mul(Int v, ast *a) {
  ast_assign_modifiable_ref(a, &a);

  if (is(a, ast::mul)) {
    insert(a, integer(v), 0);
  } else {
    a = create(ast::mul, {integer(v), a});
  }

  return a;
}

inline ast *ast_set_to_mul(ast *a, ast *b) {
  ast_assign_modifiable_ref(a, &a);

  if (is(a, ast::mul)) {
    insert(a, b, 0);
  } else {
    a = create(ast::mul, {a, b});
  }

  return a;
}

inline ast *ast_set_op_to_mul(ast *a, size_t i, Int v) {
  ast_assign_modifiable_ref(a, &a);

  ast *t = operand(a, i);

  t = ast_set_to_mul(v, t);

  return ast_replace_operand(a, t, i);
}

inline ast *ast_set_op_to_mul(ast *a, size_t i, ast *v) {
  ast_assign_modifiable_ref(a, &a);

  ast *t = operand(a, i);

  t = ast_set_to_mul(v, t);

  return ast_replace_operand(a, t, i);
}

inline ast *ast_set_to_pow(ast *a, Int e) {
  ast_assign_modifiable_ref(a, &a);

  // if(is(a, ast::pow)) {
  // 	ast_delete(operand(a, 1));

  // 	ast_set_operand(a, integer(e), 1);

  // 	return a;
  // }

  return create(ast::pow, {a, integer(e)});
}

inline ast *ast_set_to_add(ast *a, ast *e) {
  ast_assign_modifiable_ref(a, &a);

  if (is(a, ast::add)) {
    insert(a, e, size_of(a));

    return a;
  }

  return create(ast::add, {a, e});
}

inline ast *ast_set_op_to_add(ast *a, size_t i, ast *v) {
  ast_assign_modifiable_ref(a, &a);

  ast *t = operand(a, i);

  t = ast_set_to_add(t, v);

  return ast_replace_operand(a, t, i);
}

inline ast *ast_set_op_pow_add_to_deg(ast *a, size_t i, ast *e) {
  assert(is(operand(a, i), ast::pow));

  ast_assign_modifiable_ref(a, &a);

  ast *b = operand(a, i);

  ast *p = create(
      ast::pow, {ast_inc_ref(operand(b, 0)),
                 create(ast::add, {ast_inc_ref(operand(b, 1)), e})});

  ast_delete(b);

  ast_set_operand(a, p, i);

  return a;
}

inline ast *ast_set_op_to_pow(ast *a, size_t i, Int v) {
  ast_assign_modifiable_ref(a, &a);

  ast *t = create(ast::pow, {operand(a, i), integer(v)});

  return ast_replace_operand(a, t, i);
}

inline ast *ast_set_op_to_pow(ast *a, size_t i, ast *v) {
  ast_assign_modifiable_ref(a, &a);

  ast *t = create(ast::pow, {operand(a, i), v});

  return ast_replace_operand(a, t, i);
}

inline ast *ast_detatch_operand(ast *a, size_t i) {
  ast *b = operand(a, i);

  ast_set_operand(a, 0, i);

  remove(a, i);

  return b;
}

inline ast *eval_add_consts(ast *u, size_t i, ast *v, size_t j) {
  ast *a = operand(u, i);
  ast *b = operand(v, j);

  if (a == 0 || b == 0) {
    return u;
  }

  return ast_set_op_inplace_add_consts(u, i, b);
}

inline ast *eval_mul_consts(ast *u, size_t i, ast *v, size_t j) {
  ast *a = operand(u, i);
  ast *b = operand(v, j);

  if (a == 0 || b == 0) {
    return u;
  }

  return ast_set_op_inplace_mul_consts(u, i, b);
}

inline ast *eval_add_int(ast *a, Int b) {
  if (is(a, ast::integer)) {
    return ast_set_to_int(a, get_val(a) + b);
  }

  assert(is(a, ast::fraction));

  Int num = get_val(operand(a, 0));
  Int den = get_val(operand(a, 1));

  num = b * den + num;

  Int cff = abs(gcd(num, den));

  if (den / cff == 1) {
    return ast_set_to_int(a, num / cff);
  }

  return ast_set_to_fra(a, num / cff, den / cff);
}

inline ast *eval_add_nconst(ast *u, size_t i, ast *v, size_t j) {
  assert(is(u, ast::add) && is(v, ast::add));

  assert(is(operand(u, i), ast::summable));
  assert(is(operand(v, j), ast::summable));

  ast *a = operand(u, i);
  ast *b = operand(v, j);

  if (a == 0 || b == 0) {
    return 0;
  }

  if (is(a, ast::pow) && is(b, ast::symbol)) {
    return 0;
  }

  if (is(a, ast::symbol) && is(b, ast::pow)) {
    return 0;
  }

  int kind = kind_of(a) & kind_of(b);

  if (kind & (ast::symbol | ast::pow)) {
    if (compare(a, b, ast::add) == 0) {
      return ast_set_op_to_mul(u, i, 2);
    }

    return 0;
  }

  long size_a = size_of(a);

  if (kind & ast::mul) {
    long size_b = size_of(b);

    ast *c;

    long size_c = -1;

    if (is(operand(a, 0), ast::integer) &&
        is(operand(b, 0), ast::integer) &&
        std::abs(size_a - size_b) != 0) {
      return 0;
    }
    if (size_b > size_a) {
      c = a;
      a = b;
      b = c;

      size_c = size_b;
      size_b = size_a;
      size_a = size_c;
    }

    assert(size_a == size_b || size_a == size_b + 1);

    long size =
        size_b - (is(operand(b, 0), ast::constant) ? 1 : 0);

    for (long x = 0; x < size; x++) {
      if (compare(operand(a, size_a - x - 1),
                  operand(b, size_b - x - 1), ast::add) != 0) {
        return 0;
      }
    }

    int ka = kind_of(operand(a, 0));
    int kb = kind_of(operand(b, 0));

    // NOTE: sinse we are getting a modifiable reference
    // from the reduce_add method, the following operations
    // are valid.
    assert(u->ref_count == 1);

    ast_assign_modifiable_ref(u, &u);

    assert(operand(u, i)->ref_count == 1);

    ast_assign_modifiable_ref(operand(u, i), &a);

    if ((ka & ast::constant) && (kb & ast::constant)) {
      a = ast_set_op_inplace_add_consts(a, 0, operand(b, 0));
    } else if (ka & ast::constant) {
      a = ast_set_op_inplace_add_consts(a, 0, 1);
    } else {
      a = ast_set_to_mul(2, a);
    }

    ast_set_operand(u, a, i);

    if (size_c != -1) {
      ast_set_operand(u, a, i);
      ast_set_operand(v, b, j);
    }

    return u;
  }

  if (is(b, ast::mul)) {
    return 0;
  }

  // a is a mul and b is a sym or a pow
  assert(is(a, ast::mul));
  assert(is(b, ast::symbol | ast::pow));

  if (size_a > 2) {
    return 0;
  }

  ast *a0 = operand(a, 0);
  ast *a1 = operand(a, 1);

  long ki = kind_of(a1) & kind_of(b);

  if (!is(a0, ast::constant) || !ki) {
    return 0;
  }

  if (compare(b, a1, ast::mul) == 0) {
    // NOTE: sinse we are getting a modifiable reference
    // from the reduce_add method, the following operations
    // are valid.

    assert(u->ref_count == 1);

    ast_assign_modifiable_ref(u, &u);

    assert(operand(u, i)->ref_count == 1);

    ast_assign_modifiable_ref(operand(u, i), &a);

    a = ast_set_op_inplace_add_consts(a, 0, 1);

    ast_set_operand(u, a, i);

    return u;
  }

  return 0;
}

inline ast *eval_mul_nconst(ast *u, size_t i, ast *v, size_t j) {
  assert(is(u, ast::mul) && is(v, ast::mul));

  assert(is(operand(u, i), ast::multiplicable));
  assert(is(operand(v, j), ast::multiplicable));

  ast *a = operand(u, i);
  ast *b = operand(v, j);

  if (a == 0 || b == 0) {
    return 0;
  }

  if (is(a, ast::add) && is(b, ast::add)) {

    if (compare(a, b, ast::mul) == 0) {
      return ast_set_op_to_pow(u, i, 2);
    }

    return 0;
  }

  // printf("--------> %s   %%%%%%%%   %s\n", to_string(a).c_str(),
  // to_string(b).c_str());
  if (is(a, ast::add) && is(b, ast::pow)) {

    // printf("--------> %s   *****   %s\n", to_string(a).c_str(),
    // to_string(b).c_str());

    if (compare(a, operand(b, 0), ast::mul) == 0) {
      ast *e = create(ast::add,
                          {integer(1), ast_inc_ref(operand(b, 1))});

      u = ast_set_op_to_pow(u, i, e);
      ast_set_operand(u, reduce(operand(u, i)), i);
      return u;
    }

    return 0;
  }

  if (is(a, ast::pow) && is(b, ast::add)) {
    // printf("--------> %s   *****   %s\n", to_string(a).c_str(),
    // to_string(b).c_str());

    if (compare(b, operand(a, 0), ast::mul) == 0) {
      u = ast_set_op_pow_add_to_deg(u, i, integer(1));
      ast_set_operand(u, reduce(operand(u, i)), i);
      return u;
    }

    return 0;

    // if(compare(a, b, ast::mul) == 0) {
    // 	return ast_set_op_to_pow(u, i, 2);
    // }

    return 0;
  }

  if (is(a, ast::pow) && is(b, ast::pow)) {
    if (compare(operand(a, 0), operand(b, 0), ast::mul) == 0) {
      ast *k = ast_inc_ref(operand(b, 1));

      u = ast_set_op_pow_add_to_deg(u, i, k);
      k = reduce(operand(u, i));

      if (operand(u, i) != k) {
        ast_delete(operand(u, i));
        ast_set_operand(u, k, i);
      }

      return u;
    }

    return 0;
  }

  if (is(a, ast::symbol | ast::funcall) &&
      is(b, ast::symbol | ast::funcall)) {
    if (compare(a, b, ast::mul) == 0) {
      // printf("B\n");
      ast *t = ast_set_op_to_pow(u, i, 2);

      // ast_print(t);

      return t;
    }

    return 0;
  }

  if (is(a, ast::pow) && is(b, ast::symbol | ast::funcall)) {
    if (compare(operand(a, 0), b, ast::mul) == 0) {
      ast *k = integer(1);

      u = ast_set_op_pow_add_to_deg(u, i, k);

      k = reduce(operand(u, i));

      if (operand(u, i) != k) {
        ast_delete(operand(u, i));
      }
      // printf("C\n");
      // ast_print(u);

      return ast_replace_operand(u, k, i);
    }

    return 0;
  }

  return 0;
}

ast *eval_add_add(ast *a, ast *b) {
  assert(is(a, ast::add));
  assert(is(b, ast::add));

  size_t j = 0;
  size_t i = 0;

  ast *u = 0;
  ast *v = 0;

  while (i < size_of(a) && j < size_of(b)) {
    assert(!is(operand(b, j), ast::add));

    u = operand(a, i);
    v = operand(b, j);

    if (u == 0) {
      i++;
      continue;
    }

    if (v == 0) {
      j++;
      continue;
    }

    ast *tmp = 0;

    if (is(u, ast::constant) && is(v, ast::constant)) {
      tmp = eval_add_consts(a, i, b, j);
    } else if (is(u, ast::summable) && is(v, ast::summable)) {
      tmp = eval_add_nconst(a, i, b, j);
    }

    if (tmp) {
      a = tmp;

      i = i + 1;
      j = j + 1;
    } else {
      int order = compare(u, v, ast::add);

      if (order < 0) {
        i = i + 1;
      } else {
        insert(a, ast_inc_ref(v), i++);
        j = j + 1;
      }
    }
  }

  while (j < size_of(b)) {
    if (i >= size_of(a)) {
      v = operand(b, j++);
      insert(a, ast_inc_ref(v), size_of(a));
    } else {
      u = operand(a, i);
      v = operand(b, j);

      if (v == 0) {
        j++;
      } else if (u == 0 || compare(u, v, ast::add) < 0) {
        i++;
      } else {
        insert(a, ast_inc_ref(v), i++);
        j = j + 1;
      }
    }
  }

  return a;
}

inline ast *eval_mul_mul(ast *a, ast *b) {
  assert(is(a, ast::mul));
  assert(is(b, ast::mul));

  size_t j = 0;
  size_t i = 0;

  ast *u = 0;
  ast *v = 0;

  while (i < size_of(a) && j < size_of(b)) {

    assert(!is(operand(b, j), ast::mul));

    u = operand(a, i);
    v = operand(b, j);

    if (u == 0) {
      i++;
      continue;
    }

    if (v == 0) {
      j++;
      continue;
    }

    ast *tmp = 0;

    if (is(u, ast::constant) && is(v, ast::constant)) {
      tmp = eval_mul_consts(a, i, b, j);
      a = tmp ? tmp : a;
    } else if (is(u, ast::multiplicable) &&
               is(v, ast::multiplicable)) {
      tmp = eval_mul_nconst(a, i, b, j);
      a = tmp ? tmp : a;
    }

    if (tmp) {
      i = i + 1;
      j = j + 1;
    } else {
      int order = compare(u, v, ast::mul);

      if (order < 0) {
        i = i + 1;
      } else {
        insert(a, ast_inc_ref(v), i++);
        j = j + 1;
      }
    }
  }
  // printf(">> %s\n", to_string(a).c_str());
  // printf("(%li, %li)\n", i, j);
  while (j < size_of(b)) {
    if (i >= size_of(a)) {
      v = operand(b, j++);
      insert(a, ast_inc_ref(v), size_of(a));
    } else {
      u = operand(a, i);
      v = operand(b, j);

      if (v == 0) {
        j++;
      } else if (u == 0 || compare(u, v, ast::mul) < 0) {
        i++;
      } else {
        insert(a, ast_inc_ref(v), i++);
        j = j + 1;
      }
    }
  }

  return a;
}

ast *eval_mul_int(ast *u, size_t i, Int v) {
  ast *a = operand(u, i);

  if (is(a, ast::integer)) {
    return ast_set_op_inplace_mul_consts(u, i, v);
  }

  if (is(a, ast::add | ast::sub)) {
    assert(u->ref_count == 1);

    ast_assign_modifiable_ref(u, &u);

    assert(operand(u, i)->ref_count == 1);

    ast_assign_modifiable_ref(operand(a, i), &a);

    for (size_t j = 0; j < size_of(a); j++) {
      a = ast_set_op_inplace_mul_consts(a, j, v);
    }

    ast_set_operand(u, a, i);

    return u;
  }

  if (is(a, ast::mul)) {
    return ast_set_op_to_mul(u, i, v);
  }

  if (is(a, ast::div)) {
    return eval_mul_int(a, 0, v);
  }

  if (is(a, ast::sqrt | ast::pow | ast::fact | ast::funcall |
                         ast::symbol)) {
    return ast_set_op_inplace_mul_consts(u, i, v);
  }

  assert(is(a, ast::undefined | ast::fail));

  return u;
}

ast *ast_replace_with(ast *a, ast* t) {
  ast_assign_modifiable_ref(a, &a);

  if (is(t, ast::integer)) {
    return ast_set_to_int(a, get_val(t));
  }

  if (is(t, ast::symbol)) {
    return ast_set_to_sym(a, get_id(t));
  }

  if (is(t, ast::funcall)) {
    a->ast_sym = strdup(get_id(t));

    ast_set_kind(a, ast::funcall);

		ast_allocate_operands(a, size_of(t));

		for(size_t i = 0; i < size_of(t); i++) {
			a->ast_childs[i] = ast_inc_ref(operand(t, i));
		}

    return a;
  }

  ast_set_kind(a, kind_of(t));

	ast_allocate_operands(a, size_of(t));

	for(size_t i = 0; i < size_of(t); i++) {
		a->ast_childs[i] = ast_inc_ref(operand(t, i));
	}

	return a;
}


ast *ast_raise_to_first_op(ast *a) {
  ast_assign_modifiable_ref(a, &a);

  if (is(operand(a, 0), ast::integer)) {
    return ast_set_to_int(a, get_val(operand(a, 0)));
  }

  if (is(operand(a, 0), ast::symbol)) {
    return ast_set_to_sym(a, get_id(operand(a, 0)));
  }

  if (is(operand(a, 0), ast::funcall)) {
    a->ast_sym = strdup(get_id(operand(a, 0)));

    ast_set_kind(a, ast::funcall);

    ast *t = operand(a, 0);

    ast **t_childs = a->ast_childs;
    size_t t_size = a->size_of;
    size_t t_rsize = a->ast_reserved_size;

    a->ast_childs = t->ast_childs;
    a->size_of = t->size_of;
    a->ast_reserved_size = t->ast_reserved_size;

    t->ast_childs = t_childs;
    t->size_of = t_size;
    t->ast_reserved_size = t_rsize;

    ast_delete(t);

    return a;
  }

  ast *t = operand(a, 0);

  ast_set_operand(a, 0, 0);

  ast::kind k = kind_of(a);

  ast_set_kind(a, kind_of(t));
  ast_set_kind(t, k);

  ast **t_childs = a->ast_childs;
  size_t t_size = a->size_of;
  size_t t_rsize = a->ast_reserved_size;

  a->ast_childs = t->ast_childs;
  a->size_of = t->size_of;
  a->ast_reserved_size = t->ast_reserved_size;

  t->ast_childs = t_childs;
  t->size_of = t_size;
  t->ast_reserved_size = t_rsize;

  ast_delete(t);

  return a;
}

ast *reduce_add(ast *a, bool print, ast *p) {
  ast_assign_modifiable_ref(a, &a);
  p = p ? p : a;

  ast *t = 0;

  for (size_t i = 0; i < size_of(a); i++) {
    t = reduce(operand(a, i), print, p);
    a = ast_replace_operand(a, t, i);
  }

  a = sort_childs(a, 0, size_of(a) - 1);

  if (is(operand(a, 0), ast::add)) {
    t = ast_detatch_operand(a, 0);

    eval_add_add(a, t);

    ast_delete(t);
  }

  size_t j = 0;

  for (long i = 1; i < (long)size_of(a); i++) {

    ast *aj = operand(a, j);
    ast *ai = operand(a, i);

    t = 0;

    if (is(ai, ast::fail) || is(aj, ast::fail)) {
      return ast_set_to_fail(a);
    } else if (is(ai, ast::undefined) ||
               is(aj, ast::undefined)) {
      return ast_set_to_undefined(a);
    } else if (ast_is_zero(operand(a, j))) {
      remove(a, j);
    } else if (is(ai, ast::add)) {
      ai = ast_detatch_operand(a, i--);
      a = eval_add_add(a, ai);
      ast_delete(ai);
    } else if (is(aj, ast::constant) &&
               is(ai, ast::constant)) {

      t = eval_add_consts(a, j, a, i);

      if (t) {
        a = t;
        remove(a, i--);
      }

    } else if (is(aj, ast::summable) &&
               is(ai, ast::summable)) {
      t = eval_add_nconst(a, j, a, i);

      if (t) {
        a = t;
        remove(a, i--);
      }
    }

    if (!t)
      j = i;

    // // TODO: code like this could be used to return the history of operations
    // if (tmp && print) {
    //   printf("%s\n", to_string(p).c_str());
    // }
  }

  if (size_of(a) == 0) {
    ast_delete_operands(a);
    ast_delete_metadata(a);
    ast_set_kind(a, ast::integer);

    a->ast_int = new Int(0);

  } else if (size_of(a) == 1) {
    a = ast_raise_to_first_op(a);
  }

  return a;
}

ast *reduce_mul(ast *a, bool print, ast *parent) {
  ast_assign_modifiable_ref(a, &a);

  // ast* p = ast_inc_ref(a);

  for (size_t i = 0; i < size_of(a); i++) {
    ast_replace_operand(
        a, reduce(operand(a, i), print, parent ? parent : a), i);
  }

  ast *t = 0;

	a = sort_childs(a, 0, size_of(a) - 1);

  size_t j = 0;

  t = 0;

  if (is(operand(a, 0), ast::mul)) {
    t = ast_detatch_operand(a, 0);
    eval_mul_mul(a, t);

    ast_delete(t);
  }

  // printf("---: %s\n", to_string(a).c_str());
  for (long i = 1; i < (long)size_of(a); i++) {
    ast *aj = operand(a, j);
    ast *ai = operand(a, i);

    t = 0;

    if (is(ai, ast::fail) || is(aj, ast::fail)) {
      return ast_set_to_fail(a);
    } else if (is(ai, ast::undefined) ||
               is(aj, ast::undefined)) {
      return ast_set_to_undefined(a);
    } else if (ast_is_zero(operand(a, i)) ||
               ast_is_zero(operand(a, j))) {
      return ast_set_to_int(a, 0);
    } else if (is(ai, ast::mul)) {
      ast_set_operand(a, 0, i);
      remove(a, i--);
      a = eval_mul_mul(a, ai);
      ast_delete(ai);
    } else if (is(aj, ast::constant) &&
               is(ai, ast::constant)) {

      // if(get_val(aj) == 1) {
      // 	remove(a, j);
      // 	continue;
      // }

      // if(get_val(ai) == 1) {
      // 	remove(a, i);
      // 	continue;
      // }

      t = eval_mul_consts(a, j, a, i);

      if (t) {
        a = t;
        remove(a, i--);
      }
    } else if (is(aj, ast::multiplicable) &&
               is(ai, ast::multiplicable)) {
      t = eval_mul_nconst(a, j, a, i);

      if (t) {
        a = t;
        remove(a, i--);
      }
    }

    if (t == 0) {
      j = i;
    }

    // // TODO: code like this could be used to return the history of operations
    // if (tmp && print) {
    //   printf("%s\n", to_string(parent ? parent : a).c_str());
    // }
  }
  if (is(a, ast::mul) && size_of(a) == 1) {
    ast_raise_to_first_op(a);
  }

  return a;
}

ast *reduce_sub(ast *a, bool print, ast *parent) {
  for (size_t i = 1; i < size_of(a); i++) {
    eval_mul_int(a, i, -1);
  }

  ast_set_kind(a, ast::add);

  return reduce(a, print, parent ? parent : a);
}

ast *reduce_pow(ast *a, bool print, ast *parent) {
  ast_assign_modifiable_ref(a, &a);

  ast_set_operand(a, reduce(operand(a, 1), print, parent ? parent : a),
                  1);

  // TODO: if expoent is zero return 1, if expoent is 1 return base

  ast_set_operand(a, reduce(operand(a, 0), print, parent ? parent : a),
                  0);
  if (!is(operand(a, 1), ast::integer)) {
    return a;
  }

  if (get_val(operand(a, 1)) == 1) {
		return ast_raise_to_first_op(a);
  }

  if (get_val(operand(a, 1)) == 0) {
    return ast_set_to_int(a, 1);
  }

  if (is(operand(a, 0), ast::integer)) {
    Int b = get_val(operand(a, 0));
    Int c = get_val(operand(a, 1));

    bool n = c < 0;

    c = abs(c);

    Int d = pow(b, c);

    remove(a, 1);

    if (!n || d == 1) {
      a = ast_set_to_int(a, d);
    } else {
      a = ast_set_to_fra(a, 1, d);
    }

    if (print) {
      printf("%s\n", to_string(parent ? parent : a).c_str());
    }

    return a;
  }
  if (is(operand(a, 0), ast::fraction)) {
    Int b = get_val(operand(operand(a, 0), 0));
    Int c = get_val(operand(operand(a, 0), 1));

    Int d = get_val(operand(a, 1));

    bool n = d < 0;

    d = abs(d);

    b = pow(b, d);
    c = pow(c, d);

    Int g = gcd(b, c);

    b = b / g;
    c = c / g;

    a = !n ? ast_set_to_fra(a, b, c) : ast_set_to_fra(a, c, b);

    if (print) {
      printf("%s\n", to_string(parent ? parent : a).c_str());
    }

    return a;
  }

  if (is(operand(a, 0), ast::terminal)) {
    return a;
  }

  if (is(operand(a, 0), ast::mul)) {

    long long y = get_val(operand(a, 1)).longValue();

    ast *b = ast_detatch_operand(a, 0);

    a = ast_set_to_int(a, 1);

    while (y) {
      if (y % 2 == 1) {
        a = create(ast::mul, {a, ast_inc_ref(b)});
        a = reduce(a);
      }

      y = y >> 1;

      ast *t = create(ast::mul, size_of(b));
      ast_set_size(t, size_of(b));
      for (size_t i = 0; i < size_of(b); i++) {
        ast *v = create(ast::mul, {
                                          ast_inc_ref(operand(b, i)),
                                          ast_inc_ref(operand(b, i)),
                                      });

        ast_set_operand(t, v, i);
      }

			ast_assign(&b, t);
    }

    ast_delete(b);

    return a;
  }

  return a;
}

ast *reduce_div(ast *a, bool print, ast *parent) {
  ast_assign_modifiable_ref(a, &a);

  ast_set_kind(a, ast::mul);

  a = ast_set_op_to_pow(a, 1, -1);

  if (print) {
    printf("%s\n", to_string(parent ? parent : a).c_str());
  }

  return reduce(a, print, parent ? parent : a);
}

ast *reduce_sqr(ast *a, bool print, ast *parent) {
  ast_assign_modifiable_ref(a, &a);

  ast_set_kind(a, ast::pow);

  insert(a, fraction(1, 2), 1);

  if (print) {
    printf("%s\n", to_string(parent ? parent : a).c_str());
  }

  return reduce(a, print, parent ? parent : a);
}

ast *reduce_fac(ast *a, bool print, ast *parent) {
  if (is(operand(a, 0), ast::integer)) {
    a = ast_set_to_int(a, fact(get_val(operand(a, 0))));

    if (print) {
      printf("%s\n", to_string(parent ? parent : a).c_str());
    }

    return a;
  }

  if (is(operand(a, 0), ast::fraction)) {
    Int c = fact(get_val(operand(operand(a, 0), 0)));
    Int d = fact(get_val(operand(operand(a, 0), 1)));

    Int g = abs(gcd(c, d));

    a = ast_set_to_fra(a, c / g, d / g);

    if (print) {
      printf("%s\n", to_string(parent ? parent : a).c_str());
    }

    return a;
  }

  return a;
}

ast *reduce_fra(ast *a, bool print, ast *parent) {
  Int b = get_val(operand(a, 0));
  Int c = get_val(operand(a, 1));

  Int d = abs(gcd(b, c));

  a = ast_set_to_fra(a, b / d, c / d);

  if (print) {
    printf("%s\n", to_string(parent ? parent : a).c_str());
  }

  return a;
}

ast *reduce(ast *a, bool print, ast *parent) {
  if (!a) {
    return a;
  } else if (is(a, ast::fraction)) {
    a = reduce_fra(a, print, parent);
  } else if (is(a, ast::add)) {
    a = reduce_add(a, print, parent);
  } else if (is(a, ast::mul)) {
    a = reduce_mul(a, print, parent);
  } else if (is(a, ast::sub)) {
    a = reduce_sub(a, print, parent);
  } else if (is(a, ast::div)) {
    a = reduce_div(a, print, parent);
  } else if (is(a, ast::pow)) {
    a = reduce_pow(a, print, parent);
  } else if (is(a, ast::sqrt)) {
    a = reduce_sqr(a, print, parent);
  } else if (is(a, ast::fact)) {
    a = reduce_fac(a, print, parent);
  }

  return a;
}

ast *expand_mul(ast *a, size_t i, ast *b, size_t j) {
  ast *r = operand(a, i);
  ast *s = operand(b, j);

  if (is(r, ast::add) && is(s, ast::add)) {
    ast *u = create(ast::add, size_of(r) * size_of(s));

    ast_set_size(u, size_of(r) * size_of(s));

    for (size_t k = 0; k < size_of(r); k++) {
      for (size_t t = 0; t < size_of(s); t++) {
        ast *v = create(ast::mul, {ast_inc_ref(operand(r, k)),
                                       ast_inc_ref(operand(s, t))});

        ast_set_operand(u, v, k * size_of(s) + t);
      }
    }

    return u;
  }

  if (is(r, ast::add)) {
    ast *u = create(ast::add, size_of(r));

    ast_set_size(u, size_of(r));

    for (size_t k = 0; k < size_of(r); k++) {
      ast *v = create(ast::mul,
                          {ast_inc_ref(operand(r, k)), ast_inc_ref(s)});

      ast_set_operand(u, v, k);
    }

    return u;
  }

  if (is(s, ast::add)) {
    ast *u = create(ast::add, size_of(s));

    ast_set_size(u, size_of(s));

    for (size_t k = 0; k < size_of(s); k++) {
      ast *v = create(ast::mul,
                          {ast_inc_ref(r), ast_inc_ref(operand(s, k))});

      ast_set_operand(u, v, k);
    }

    return u;
  }

  return create(ast::mul, {ast_inc_ref(r), ast_inc_ref(s)});
}

ast *expand_pow(ast *u, Int n) {
  if (n == 1)
    return ast_inc_ref(u);
  if (n == 0)
    return integer(1);

  if (is(u, ast::add)) {
    Int c = fact(n);

    ast *o = ast_copy(u);

    ast *f = ast_detatch_operand(o, 0);

    if (size_of(o) == 0)
      o = ast_set_to_int(o, 0);
    if (size_of(o) == 1)
      o = ast_raise_to_first_op(o);

    ast *s = create(ast::add, n.longValue() + 1);

    ast_set_size(s, n.longValue() + 1);

    for (Int k = 0; k <= n; k++) {
      ast *z = create(
          ast::mul,
          {integer(c / (fact(k) * fact(n - k))),
           create(ast::pow, {ast_inc_ref(f), integer(n - k)})});

      ast *t = expand_pow(o, k);

      ast *q = t ? create(ast::mul, {z, t}) : z;

      ast_set_operand(s, q, k.longValue());
    }

    ast_delete(f);
    ast_delete(o);

    return s;
  }

  if (is(u, ast::terminal)) {
    return 0;
  }

  return create(ast::pow, {
                                  ast_inc_ref(u),
                                  integer(n),
                              });

  // return reduce(t);
}

ast *expand(ast *a) {
  ast_assign_modifiable_ref(a, &a);

  if (is(a, ast::terminal)) {
    return a;
  }

  if (is(a, ast::sub | ast::div | ast::fact)) {
    a = reduce(a);
  }

  if (is(a, ast::pow)) {
		ast_set_operand(a, expand(operand(a, 0)), 0);
    ast_set_operand(a, expand(operand(a, 1)), 1);

    if (is(operand(a, 1), ast::integer)) {
      ast *t = expand_pow(operand(a, 0), get_val(operand(a, 1)));

      if (t) {
        ast_delete(a);
        a = t;
      }
    }
	}

  if (is(a, ast::mul)) {
    while (size_of(a) > 1) {
      ast_set_operand(a, expand(operand(a, 0)), 0);
      ast_set_operand(a, expand(operand(a, 1)), 1);

      insert(a, expand_mul(a, 0, a, 1), 0);

      remove(a, 1);
      remove(a, 1);
    }

    a = ast_raise_to_first_op(a);
  }

  if (is(a, ast::add)) {
    for (size_t i = 0; i < size_of(a); i++) {
      ast_set_operand(a, expand(operand(a, i)), i);
    }
  }

  return reduce(a);
}

expression::expression(ast* d) {
	root = d;

	child = (expression*)malloc(size_of(root)*sizeof(expression));

	for(size_t i = 0; i < size_of(d); i++) {
		child[i] = expression(operand(root, i));
	}

}

expression::expression(Int i) {
	child = 0;
	root = integer(i);
}

expression::expression(int i) {
	child = 0;
	root = integer(i);
}

expression::expression(expression &a) {
	root = a.root;
	child = a.child;
}

expression::expression(expression &&a) {
	root = a.root;
	child = a.child;

	a.root = 0;
	a.child = 0;
}

expression::~expression() {
  if (root)
    ast_delete(root);
  if (child)
    free(child);
}

ast *expression::remove_data() {
  ast *u = root;

	root = 0;

	free(child);

	child = 0;

  return u;
}

std::string expression::toString() const {
	return to_string(root);
}

void expression::printAST() const {
	return ast_print(root);
}
expression::expression() {
	root = 0;
	child = 0;
}

expression& expression::operator[](size_t i) {
	ast_inc_ref(child[i].root);
  return child[i];
}

expression& expression::operator=(expression& u) {
	if(root) {
		ast_delete(root);
	}

	if(child) {
		free(child);
	}

	root = ast_inc_ref(u.root);

	child = (expression*)malloc(size_of(root)*sizeof(expression));

	memcpy(child, u.child, size_of(root)*sizeof(expression));

	return *this;
}

expression& expression::operator=(expression&& u) {
	if(root) {
		ast_delete(root);
	}

	if(child) {
		free(child);
	}

	root = u.root;
	child = u.child;

	u.root = 0;
	u.child = 0;

	return *this;
}

expression expression::operator+(expression& a) {
  return expression(
      create(ast::add, {ast_inc_ref(root), ast_inc_ref(a.root)}));
}

expression expression::operator+(expression&& a) {
	return expression(create(ast::add, {ast_inc_ref(root), a.remove_data()}));
}

// expression expression::operator-(expression& a) {
// 	return create(ast::sub, { ast_inc_ref(root), ast_inc_ref(a.root) });
// }

// expression expression::operator-(expression&& a) {
// 	return create(ast::sub, { ast_inc_ref(root), a.remove_data() });
// }

// expression expression::operator*(expression& a) {
// 	return create(ast::mul, { ast_inc_ref(root), ast_inc_ref(a.root) });
// }

// expression expression::operator*(expression&& a) {
// 	return create(ast::mul, { ast_inc_ref(root), a.remove_data() });
// }

// expression expression::operator/(expression& a) {
// 	return create(ast::div, { ast_inc_ref(root), ast_inc_ref(a.root) });
// }

// expression expression::operator/(expression&& a) {
// 	return create(ast::div, { ast_inc_ref(root), a.remove_data() });
// }

} // namespace ast_teste
