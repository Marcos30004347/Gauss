
#include <cassert>
#include <cstdint>
#include <inttypes.h>
#include <stdlib.h>
#include <string.h>
#include <utility>
#include <stdio.h>

class buffer {
  buffer(uint32_t *b, int64_t *r, uint32_t *p) {
    buff = b;
    refs = r;
    prnt = p;

    incref();
  }

  uint32_t *prnt;

public:
  uint32_t *buff;
  int64_t *refs;

  buffer(const uint32_t s) {
    refs = new int64_t(1);
    prnt = buff = new uint32_t[s];
  }

  buffer() {
    refs = nullptr;
    buff = nullptr;
    prnt = nullptr;
  }

  buffer(buffer &b) {
    refs = b.refs;
    buff = b.buff;
    prnt = b.prnt;

    incref();
  }

  buffer(buffer &&b) {
    buff = b.buff;
    refs = b.refs;
    prnt = b.prnt;
  }

  ~buffer() {
    if (refs == nullptr || *refs == 0)
      return;

    decref();

    if (*refs == 0) {
      delete refs;
      delete prnt;
    }
  }

  void view(uint64_t idx, buffer &b) {
    b.prnt = prnt;
    b.refs = refs;
    b.buff = buff + idx;

    incref();
  }

  inline int64_t refcnt() { return *refs; }
  inline int64_t incref() { return *refs += 1; }
  inline int64_t decref() {
    if (*refs == 1) {
      delete prnt;
      delete refs;
      return 0;
    }
    return *refs -= 1;
  }

  inline uint32_t &operator[](uint64_t i) { return buff[i]; }

  inline buffer operator+(uint64_t i) { return buffer(buff + i, refs, prnt); }

  inline buffer operator-(uint64_t i) { return buffer(buff - i, refs, prnt); }

  inline buffer &operator=(buffer &a) {
    if (*refs == 1) {
      delete prnt;
      delete refs;
    }

    buff = a.buff;
    refs = a.refs;
    prnt = a.prnt;

    incref();

    return *this;
  }

  inline buffer &operator=(buffer &&a) {

    if (*refs == 1) {
      delete prnt;
      delete refs;
    }

    decref();

    buff = a.buff;
    refs = a.refs;
    prnt = a.prnt;

    incref();

    return *this;
  }

  inline uint32_t *operator&() const { return buff; }
};

enum Type {
	UNDEFINED = 0,
	INTEGER  = (1 << 0),
	ADDITION = (1 << 1),
};

class expr {
	static const uint32_t null_idx = -1;

	static const uint32_t kind_idx = 0;
	static const uint32_t size_idx = 1;
  static const uint32_t indx_idx = 2;
  static const uint32_t addr_idx = 3;
  static const uint64_t memo_idx = 4;
	static const uint64_t data_idx = 5;

static const uint32_t stride = 6;

  buffer data;

	inline expr(buffer &&b) { data = std::move(b); }
	inline expr(): data(1) { data[kind_idx] = Type::UNDEFINED; };

  public:

	inline expr(Type k): data(stride) {
		data[kind_idx] = k;
		data[size_idx] = 0;
		data[indx_idx] = null_idx;
		data[addr_idx] = null_idx;
		data[memo_idx] = stride;
		data[data_idx] = 0;
	}

	inline expr(uint32_t i): data(stride + 3) {
		uint32_t s = 1;

		data[kind_idx] = Type::INTEGER;
		data[size_idx] = 1;

		data[indx_idx] = stride + s;
		data[addr_idx] = data[indx_idx] + 1;

		data[memo_idx] = stride + 2;

		data[data_idx] = stride;

		data[data[indx_idx]] = i;

		data[data[indx_idx] + s] = data[indx_idx] + 1;
		data[data[addr_idx] + s + 1] = data_idx;
	}

	inline uint32_t size() { return data[size_idx]; }
	inline uint32_t memsize() { return data[memo_idx]; }

	inline uint32_t addr(uint64_t idx) { return data[data[indx_idx] + idx]; }

	inline uint32_t* indx_buffer() { return &data + data[indx_idx]; };
	inline uint32_t* addr_buffer() { return &data + data[addr_idx]; };
	inline uint32_t* data_buffer() { return &data + data[data[indx_idx]]; };

	inline void fill_with_op(uint64_t idx, expr& e) {
		data.view(data[addr(idx)] , e.data);
	}

	inline void insert(expr e, int64_t idx) {
		assert(idx <= size());

		buffer odata = data;

		data = buffer(memsize() + e.memsize() + 2);

		uint32_t* buff = &data;

		memcpy(buff, &odata, stride);

		data[size_idx] += 1;

		buff += ;
		memcpy()

	}

	expr operator[](uint64_t idx) {
		expr e;
		fill_with_op(idx, e);
		return e;
	}

	void printBuffer() {
		for(uint64_t i = 0; i < memsize(); i++) {
			printf("%u ", data[i]);
		}
		printf("\n");
	}

};
