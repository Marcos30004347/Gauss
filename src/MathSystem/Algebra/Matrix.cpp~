#include "matrix.hpp"
#include <algorithm>
#include <cmath>

using namespace algebra;

matrix::matrix()
{
	this->m_data = nullptr;
	this->m_lines = 0;
	this->m_columns = 0;
	this->m_block_heigth = 0;
	this->m_block_width = 0;
	this->m_stored_lines  = 0;
	this->m_stored_column  = 0;
}

matrix::matrix(const matrix& other)
{

	this->m_lines = other.m_lines;
	this->m_columns = other.m_columns;
	this->m_block_heigth = other.m_block_heigth;
	this->m_block_width = other.m_block_width;
	this->m_data = new double[this->m_stored_lines*this->m_stored_column];
	this->m_stored_lines  = other.m_stored_lines;
	this->m_stored_column  = other.m_stored_column;

	std::copy(other.m_data, other.m_data + (other.m_stored_lines*other.m_stored_column), this->m_data);
}

matrix::matrix(unsigned int lines, unsigned int columns, unsigned int block_width, unsigned int block_heigth, std::initializer_list<double> data)
{
	m_lines = lines;
	m_columns = columns;
	m_block_heigth = block_heigth;
	m_block_width = block_width;
	this->m_stored_lines  = std::ceil(this->m_lines/(double)this->m_block_heigth) * this->m_block_heigth;
	this->m_stored_column = std::ceil(this->m_columns/(double)this->m_block_width) * this->m_block_width;
	this->m_data = new double[this->m_stored_column*this->m_stored_lines];
	std::fill(this->m_data, this->m_data + this->m_stored_column*this->m_stored_lines, 0);
	
	// define extra space as identity
	for(int i=0; i<std::min(this->m_stored_lines - this->m_lines, this->m_stored_column - this->m_columns); i++)
	{
		int block_y = (this->m_lines + i)/this->m_block_heigth;
		int block_x = (this->m_columns + i)/this->m_block_width;

		int y = (this->m_lines + i) - block_y*this->m_block_heigth;
		int x = (this->m_columns + i) - block_x*this->m_block_width;

		this->m_data[this->stride(block_y, block_x) + y*this->m_block_width + x] = 1.f;
	}

	int idx = 0;

	for(int block_y=0; block_y<this->m_stored_lines/this->m_block_heigth; block_y++)
	{
		for(int block_x=0; block_x<this->m_stored_column/this->m_block_width; block_x++)
		{
			// Current block width and current block heigth
			unsigned int row_margin = lines - block_y*this->m_block_heigth;
			unsigned int col_margin = columns - block_x*this->m_block_width;
	
			int width = std::min(m_block_width, col_margin);
			int heigth = std::min(m_block_heigth, row_margin);

			// where current block starts 

			unsigned int idx = this->m_block_heigth * this->m_columns * block_y + block_x*this->m_block_width;

			for(int y=0; y<heigth; y++)
			{
				for(int x=0; x<width; x++)
				{
					this->m_data[this->stride(block_y, block_x) + y*this->m_block_width + x] = *(data.begin() + idx++);
				}
				//this->m_stored_lines - this->m_lines + m_block_width - width;
				idx += this->m_columns - (block_x+1)*this->m_block_width + (block_x)*this->m_block_width + m_block_width - width;
			}
		}
	}
}

matrix::matrix(unsigned int lines, unsigned int columns, unsigned int block_width, unsigned int block_heigth, double* data)
{
	m_lines = lines;
	m_columns = columns;
	m_block_heigth = block_heigth;
	m_block_width = block_width;

	this->m_stored_lines  = std::ceil(this->m_lines/(double)this->m_block_heigth) * this->m_block_heigth;
	this->m_stored_column = std::ceil(this->m_columns/(double)this->m_block_width) * this->m_block_width;
	
	this->m_data = new double[this->m_stored_lines*this->m_stored_column];
	std::fill(this->m_data, this->m_data + this->m_stored_column*this->m_stored_lines, 0);
	
	// define extra space as identity
	for(int i=0; i<std::min(this->m_stored_lines - this->m_lines, this->m_stored_column - this->m_columns); i++)
	{
		int block_y = (this->m_lines + i)/this->m_block_heigth;
		int block_x = (this->m_columns + i)/this->m_block_width;

		int y = (this->m_lines + i) - block_y*this->m_block_heigth;
		int x = (this->m_columns + i) - block_x*this->m_block_width;

		this->m_data[this->stride(block_y, block_x) + y*this->m_block_width + x] = 1.f;
	}

	int idx = 0;

	for(int block_y=0; block_y<this->m_stored_lines/this->m_block_heigth; block_y++)
	{
		for(int block_x=0; block_x<this->m_stored_column/this->m_block_width; block_x++)
		{
			// Current block width and current block heigth
			unsigned int row_margin = lines - block_y*this->m_block_heigth;
			unsigned int col_margin = columns - block_x*this->m_block_width;
	
			int width = std::min(m_block_width, col_margin);
			int heigth = std::min(m_block_heigth, row_margin);

			// unsigned int idx = block_y*this->m_block_heigth*this->m_block_width + block_x*this->m_block_width;
			unsigned int idx = this->m_block_heigth * this->m_columns * block_y + block_x*this->m_block_width;

			for(int y=0; y<heigth; y++)
			{
				for(int x=0; x<width; x++)
				{
					this->m_data[this->stride(block_y, block_x) + y*this->m_block_width + x] = data[idx];
				}
				idx += this->m_columns - (block_x+1)*this->m_block_width + (block_x)*this->m_block_width + m_block_width - width;
			}
		}
	}
}

matrix::matrix(unsigned int lines, unsigned int columns, unsigned int block_width, unsigned int block_heigth)
{
	m_lines = lines;
	m_columns = columns;
	m_block_heigth = block_heigth;
	m_block_width = block_width;

	this->m_stored_lines  = std::ceil(this->m_lines/(double)this->m_block_heigth) * this->m_block_heigth;
	this->m_stored_column = std::ceil(this->m_columns/(double)this->m_block_width) * this->m_block_width;	
	
	this->m_data = new double[this->m_stored_lines*this->m_stored_column];
	std::fill(this->m_data, this->m_data + this->m_stored_column*this->m_stored_lines, 0);

	// define extra space as identity
	for(int i=0; i<std::min(this->m_stored_lines - this->m_lines, this->m_stored_column - this->m_columns); i++)
	{
		int block_y = (this->m_lines + i)/this->m_block_heigth;
		int block_x = (this->m_columns + i)/this->m_block_width;

		int y = (this->m_lines + i) - block_y*this->m_block_heigth;
		int x = (this->m_columns + i) - block_x*this->m_block_width;

		this->m_data[this->stride(block_y, block_x) + y*this->m_block_width + x] = 1.f;
	}
}

matrix::~matrix()
{

	if(this->m_data)
		delete[] this->m_data;
}

const unsigned int matrix::lines() const
{
	return this->m_lines;
}

const unsigned int matrix::columns() const
{
	return this->m_columns;
}

const unsigned int matrix::blockWidth() const
{
	return this->m_block_width;
}

const unsigned int matrix::blockHeight() const
{
	return this->m_block_heigth;
}

// #include <string.h>

matrix& matrix::operator=(const matrix& other)
{
	this->m_stored_column = other.m_stored_column;
	this->m_stored_lines  = other.m_stored_lines;
	this->m_lines 				= other.m_lines;
	this->m_columns 			= other.m_columns;
	this->m_block_width 	= other.m_block_width;
	this->m_block_heigth 	= other.m_block_heigth;

	if(this->m_data) delete[] this->m_data;
	
	this->m_data = new double[this->m_stored_lines*this->m_stored_column];

	std::copy(other.m_data, other.m_data + (other.m_stored_lines * other.m_stored_column), this->m_data);

	return *this;
}


matrix::matrix(double k): m_data{1, 1, 1, 1, {k}} {}
matrix::matrix(): m_data{0, 0, 0, 0} {}
matrix::matrix(unsigned int l, unsigned int c, double* data): m_data{l, c, 1, 1, data} {}
matrix::matrix(unsigned int l, unsigned int c, std::initializer_list<double> data, unsigned int bx, unsigned int by): m_data{l, c, bx, by, data} {}
matrix::matrix(unsigned int l, unsigned int c, unsigned int bx, unsigned int by): m_data{l, c, bx, by} {}


void add(matrix* C, const matrix* const A, const matrix* const B, bool A_T, bool B_T)
{
	assert(A->columns() == B->columns());
	assert(A->lines() == B->lines());

	for(int i=0; i<C->lines(); i+= C->blockHeight()) 
	{
		for(int j=0; j<C->columns(); j+= C->blockWidth()) 
		{
			unsigned int row_margin = C->lines() - i;
			unsigned int col_margin = C->columns() - j;
	
			int width = std::min(C->blockWidth(), col_margin);
			int heigth = std::min(C->blockHeight(), row_margin);

			for(int y=0; y<heigth; y++)
			{
				for(int x=0; x<width; x++)
				{
					int Ci = i+y;
					int Cj = j+x;

					C->set(
						Ci, Cj,
						A->get((1 - A_T) * Ci + A_T * Cj, (1 - A_T) * Cj + A_T * Ci) +
						B->get((1 - B_T) * Ci + B_T * Cj, (1 - B_T) * Cj + B_T * Ci)
					);
				}
			}
		}
	}
}

void sub(matrix* C, const matrix* const A, const matrix* const B, bool A_T, bool B_T)
{
	assert(A->columns() == B->columns());
	assert(A->lines() == B->lines());

	for(int i=0; i<C->lines(); i+= C->blockHeight()) 
	{
		for(int j=0; j<C->columns(); j+= C->blockWidth()) 
		{
			unsigned int row_margin = C->lines() - i;
			unsigned int col_margin = C->columns() - j;
	
			int width = std::min(C->blockWidth(), col_margin);
			int heigth = std::min(C->blockHeight(), row_margin);

			for(int y=0; y<heigth; y++)
			{
				for(int x=0; x<width; x++)
				{
					int Ci = i+y;
					int Cj = j+x;

					C->set(
						Ci, Cj,
						A->get((1 - A_T) * Ci + A_T * Cj, (1 - A_T) * Cj + A_T * Ci) -
						B->get((1 - B_T) * Ci + B_T * Cj, (1 - B_T) * Cj + B_T * Ci)
					);
				}
			}
		}
	}
}


void div(matrix* C, const matrix* const A, const matrix* const B, bool A_T, bool B_T)
{
	assert(A->columns() == B->columns());
	assert(A->lines() == B->lines());

	for(int i=0; i<C->m_lines; i+= C->blockHeight()) 
	{
		for(int j=0; j<C->m_columns; j+= C->blockWidth()) 
		{
			unsigned int row_margin = C->m_lines - i;
			unsigned int col_margin = C->m_columns - j;
	
			int width = std::min(C->m_block_width, col_margin);
			int heigth = std::min(C->m_block_heigth, row_margin);

			for(int y=0; y<heigth; y++)
			{
				for(int x=0; x<width; x++)
				{
					int Ci = i+y;
					int Cj = j+x;

					C->set(
						Ci, Cj,
						A->get((1 - A_T) * Ci + A_T * Cj, (1 - A_T) * Cj + A_T * Ci)/
						B->get((1 - B_T) * Ci + B_T * Cj, (1 - B_T) * Cj + B_T * Ci)
					);
				}
			}
		}
	}
}

void LUdecompose(matrix* L, matrix* U, const matrix* const A)
{
	int i = 0, j = 0, k = 0;

	int n = A->lines();

	for (i = 0; i < n; i++)
	{
		for (j = 0; j < n; j++)
		{
			if (j < i)
			{
				L->set(j, i, 0);
			}
			else
			{
				L->set(j, i, A->get(j, i));
				for (k = 0; k < i; k++) {
					L->set(j,i, L->get(j,i) - L->get(j,k)*U->get(k,i));
				}
			}
		}
		for (j = 0; j < n; j++)
		{
				if (j < i)
				{
					U->set(i, j, 0);
				}
				else if (j == i)
				{
					U->set(i,j,1); 
				}
				else {
					U->set(i,j, A->get(i,j)/L->get(i,i));

					for (k = 0; k < i; k++) {
							U->set(i,j, U->get(i,j) - ((L->get(i,k)*U->get(k,j))/L->get(i,i)));
					}
				}
		}
	}
}

void pivot(matrix* A, int i, int k)
{
	for(int j=0; j<A->columns(); j++)
	{
		double tmp = A->get(i, j);

		A->set(i,j, A->get(k, j));
		A->set(k,j, tmp);
	}
}

int LUPdecompose(matrix* A, matrix* P)
{
	int i, j, k, imax;
	double maxA, absA;
	int N = A->lines();
	
	for(i=0; i<=N; i++)
	{
		P->set(i,0, i);
	}
	
	for(i=0; i<N; i++)
	{
		maxA = 0.f;
		imax = i;

		for(k=i;k<N;k++)
		{
			if((absA = fabs(A->get(k,i))) > maxA)
			{
				maxA = absA;
				imax = k;
			}
		}

		if(maxA < 0.00001) return 0;

		if(imax != i)
		{
			j = P->get(i,0);
			P->set(i, 0, P->get(imax, 0));
			P->set(imax, 0, j);
			pivot(A, i, imax);
			P->set(N, 0, P->get(N,0)+1);
		}

		for(j=i+1; j<N; j++)
		{
			A->set(j,i, A->get(j,i)/A->get(i,i));
			for(k=i+1; k<N; k++)
			{
				A->set(j,k, A->get(j,k) - A->get(j,i)* A->get(i,k));
			}
		}
	}
	return 1;
}

int LUPSolve(const matrix* const A, const matrix* const P,  const matrix* const b,  matrix* x)
{
	int N = A->lines();

	for(int i=0; i<N; i++)
	{
		x->set(i,0, b->get(P->get(i,0), 0));
		for(int k=0; k<i; k++)
		{
			x->set(i,0, x->get(i,0) - A->get(i, k) * x->get(k,0));
		}
	}

	for(int i=N-1; i>=0; i--)
	{
		for(int k=i+1; k<N; k++)
		{
			x->set(i, 0, x->get(i,0) - A->get(i,k)*x->get(k,0));
		}
		x->set(i, 0, x->get(i,0)/A->get(i,i));
	}

	return 1;
}

int LUPInvet(const matrix* const A, const matrix* const P,  matrix* A_Inv)
{
	int N = A->lines();

	for(int j=0; j<N; j++)
	{
		for(int i=0; i<N; i++)
		{
			A_Inv->set(i, j, static_cast<int>(P->get(i,0)) == j ? 1.f : 0.f);

			for(int k=0; k<i; k++)
			{
				A_Inv->set(i, j, A_Inv->get(i,j) - A->get(i,k)*A_Inv->get(k,j));
			}
		}

		for(int i=N-1; i>=0; i--)
		{
			for(int k=i+1; k<N; k++)
			{
				A_Inv->set(i, j, A_Inv->get(i,j) - A->get(i,k)*A_Inv->get(k,j));
			}
			A_Inv->set(i, j, A_Inv->get(i,j) / A->get(i,i));

		}
	}

	return 1;
}

double LUPDeterminant(const matrix* const A, const matrix* const P)
{
	double det = A->get(0,0);
	int N = A->lines();

	for(int i=1; i<N; i++)
	{
		det *= A->get(i, i);
	}

	return (static_cast<int>(P->get(N,0)) - N)%2 == 0 ? det : -det;
}


void div(matrix* C, const matrix* const A, const float alpha)
{
	for(int i=0; i<C->m_lines; i+= C->blockHeight()) 
	{
		for(int j=0; j<C->m_columns; j+= C->blockWidth()) 
		{
			unsigned int row_margin = C->m_lines - i;
			unsigned int col_margin = C->m_columns - j;
	
			int width = std::min(C->m_block_width, col_margin);
			int heigth = std::min(C->m_block_heigth, row_margin);

			for(int y=0; y<heigth; y++)
			{
				for(int x=0; x<width; x++)
				{
					int Ci = i+y;
					int Cj = j+x;

					C->set(
						Ci, Cj,
						A->get(Ci, Cj)/
						alpha
					);
				}
			}
		}
	}
}

void swapLines(matrix* A, i32 i, i32 k)
{
	for(i32 j=0; j<A->columns(); j++)
	{
		double tmp = A->get(i, j);

		A->set(i,j, A->get(k, j));
		A->set(k,j, tmp);
	}
}

unsigned int findPivo(matrix* M, unsigned int l, unsigned int c)
{
	unsigned int best = l;
	double val = fabs(M->get(l,c));

	for(unsigned int r=l+1; r<M->lines(); r++)
	{
		double curr = fabs(M->get(r, c));
		if(curr > val)
		{
			best = r;
			val = curr;
		}
	}

	return best;
}

void MatrixEchelonForm::toEchelonForm(matrix* M)
{
	unsigned int rows = M->lines();
	unsigned int cols = M->columns();

	unsigned int r = 0;

	for(unsigned int c=0; c<cols; c++)
	{

		unsigned int pivo = findPivo(M, r, c);
		if(pivo != r) {
			// std::cout << "swap " << r << " " << pivo << "\n";
			swapLines(M, r, pivo);
			// std::cout << "now\n";
			// for(i64 i=0; i<rows; i++)
			// {
			// 	for(i64 j=0; j<cols; j++)
			// 	{
			// 		std::cout << std::defaultfloat << M->get(i,j) << " ";
			// 	}
			// 	std::cout << "\n";
			// }
			// std::cout << "\n";
			// for(i64 i=0; i<rows; i++)
			// {
			// 	for(i64 j=0; j<cols; j++)
			// 	{
			// 		std::cout << std::defaultfloat << M->get(i,j) << " ";
			// 	}
			// 	std::cout << "\n";
			// }
			// std::cout << "\n";
		}

		double b = M->get(r, c);
		
		for(unsigned int j=c; j<cols; j++)
		{
			double a = M->get(r, j);
			M->set(r, j, a/b);
		}

		if(r > 0)
		{
			for(unsigned int l=0; l<r; l++)
			{
				double k = M->get(l, c);
				for(unsigned int j=c; j<cols; j++)
				{
					double a = M->get(l, j);
					double b = M->get(r, j);

					M->set(l, j, a - b*k);
				}
			}
			// std::cout << "above\n";
			// for(i64 i=0; i<rows; i++)
			// {
			// 	for(i64 j=0; j<cols; j++)
			// 	{
			// 		std::cout << std::defaultfloat << M->get(i,j) << " ";
			// 	}
			// 	std::cout << "\n";
			// }
			// std::cout << "\n";
		}


		if(r < rows-1)
		{

			for(unsigned int l=r+1; l<rows; l++)
			{
				double k = M->get(l, c);
				for(unsigned int j=c; j<cols; j++)
				{
					double a = M->get(l, j);
					double b = M->get(r, j);

					M->set(l, j, a - b*k);
				}
			}
			// std::cout << "bellow\n";
			// for(i64 i=0; i<rows; i++)
			// {
			// 	for(i64 j=0; j<cols; j++)
			// 	{
			// 		std::cout << std::defaultfloat << M->get(i,j) << " ";
			// 	}
		// 	// 	std::cout << "\n";
		// 	// }
		// 	// std::cout << "\n";
		}

		// for(i64 i=0; i<rows; i++)
		// {
		// 	for(i64 j=0; j<cols; j++)
		// 	{
		// 		std::cout << std::defaultfloat << M->get(i,j) << " ";
		// 	}
		// 	std::cout << "\n";
		// }
		// std::cout << "\n";
		// std::cout << "\n";
		r+=1;

		if(r == rows)
			break;
	}
	// unsigned int lead = 0;
	// unsigned int rowCount = M->lines();
	// unsigned int columnCount = M->columns();
	// std::cout << "\n";
	// for(i64 i=0; i<rowCount; i++)
	// {
	// 	for(i64 j=0; j<columnCount; j++)
	// 	{
	// 		std::cout << std::fixed << std::setprecision(30) << M->get(i,j) << " ";
	// 	}
	// 	std::cout << "\n";
	// }
	// std::cout << "\n";
	// for(i64 r=0; r<rowCount; r++)
	// {
	// 	if(columnCount <= lead) break;
		
	// 	i64 i = r;
		
	// 	while(M->get(i, lead) == 0)
	// 	{
	// 		i = i + 1;
	// 		if(rowCount == i)
	// 		{
	// 			i = r;
	// 			lead = lead + 1;
	// 			if(columnCount == lead)
	// 				break;
	// 		}
	// 	}
	
	// 	if(i != r) swapLines(M, i, r);
		
	// 	double tmp = M->get(r, lead);
	
	// 	if(tmp != 0.0)
	// 	{
	// 		for(i32 j=0; j<columnCount; j++)
	// 			M->set(r,j, M->get(r,j)/tmp);
	// 	}

	// 	for(i64 j=0; j<columnCount; j++)
	// 	{
	// 		std::cout << M->get(r,j) << " ";
	// 	}
	// 	std::cout << "\n";
	// 	std::cout << "\n";

	// 	for(i64 i=0; i<rowCount; i++)
	// 	{
	// 		if(i != r)
	// 		{
	// 			double k = M->get(i, lead);
	// 			for(i32 j=0; j<columnCount; j++)
	// 			{
	// 				// std::cout << M->get(i,j) << " - " << M->get(r,j) << " * " << k << " = " << M->get(i,j) - M->get(r,j)*k <<  "\n";

	// 				M->set(i,j, M->get(i,j) - M->get(r,j)*k);
	// 			}
	// 		}
	// 	}

	// 	for(i64 i=0; i<rowCount; i++)
	// 	{
	// 		for(i64 j=0; j<columnCount; j++)
	// 		{
	// 			std::cout << std::defaultfloat << M->get(i,j) << " ";
	// 		}
	// 		std::cout << "\n";
	// 	}
	// 	std::cout << "\n";

	// 	lead = lead+1;
	// }
}


void nullSpace(matrix* M, matrix& ns) {
	
	MatrixEchelonForm::toEchelonForm(M);
	// std::cout << M->lines() << " " << M->columns() << "\n";
	// Matrix _m(*M);
	// printMatrix(_m);
	// std::cout << _m.rows() << " " << _m.columns() << "\n";

	unsigned int columns = M->columns();
	unsigned int lead = 0;

	while(M->get(lead, lead) == 1 && lead < M->lines())
		lead++;

	unsigned int rank = columns - lead;

	if(rank == 0)
	{
		std::vector<double> zeros(columns, 0);
		ns = matrix(1,columns,1,1, zeros.data());
		return;
	}

	std::vector<double> basis(rank*columns, 0);
	// std::cout << "\n";
	// std::cout << "columns " << columns << "\n";
	// std::cout << "rank " << rank << "\n";

	for(i64 i=1; i<=rank; i++)
		basis[i*columns - rank + (i-1)] = 1;
	
	for(i64 i=0; i<rank; i++)
		for(i64 j=0; j<M->lines(); j++)
			basis[i*columns + j] -= M->get(j, lead+i);
		
	ns = matrix(rank, columns, 1, 1, basis.data());
}


void transpose(matrix* C, const matrix* const A)
{
	// code for GPU multiplication
	for(int i=0; i<C->lines(); i+= C->blockHeight()) 
	{
		for(int j=0; j<C->columns(); j+= C->blockWidth()) 
		{
			// loops above will become one block
			for(int y=0; y<C->blockHeight(); y++)
			{
				for(int x=0; x<C->blockWidth(); x++)
				{
					// loops above will become one thread
					C->set(i+y, j+x, A->get(j+x, i+y));
				}
			}
		}
	}
}

void mul(matrix* C, const matrix* const A, const matrix* const B, bool A_T, bool B_T)
{
	assert(A->columns() == B->lines());

	// code for GPU multiplication
	for(int i=0; i<C->lines(); i+= C->blockHeight()) 
	{
		for(int j=0; j<C->columns(); j+= C->blockWidth()) 
		{
			// loops above will become one block
			for(int y=0; y<C->m_block_heigth; y++)
			{
				for(int x=0; x<C->m_block_width; x++)
				{
					// loops above will become one thread
					double acc = 0;

					int Ci = i + y, Cj = j + x;
					for(int k=0; k < A->columns(); k += std::min(A->blockWidth(), B->blockHeight()) /*C->blockWidth()*/)
					{
						for(int q=0; q < std::min(A->blockWidth(), B->blockHeight()); q++)
						{
							int Ai = (i + y), Aj = (k + q);
							int Bi = (k + q), Bj = (j + x);

							bool Ai_bounds = Ai < A->m_stored_lines;
							bool Aj_bounds = Aj < A->m_stored_column;
							bool Bi_bounds = Bi < B->m_stored_lines;
							bool Bj_bounds = Bj < B->m_stored_column;

							Ai = (A->m_stored_lines-1)*!Ai_bounds  + Ai*Ai_bounds;
							Aj = (A->m_stored_column-1)*!Aj_bounds + Aj*Aj_bounds;
							Bi = (B->m_stored_lines-1)*!Bi_bounds  + Bi*Bi_bounds;
							Bj = (B->m_stored_column-1)*!Bj_bounds + Bj*Bj_bounds;

							acc += A->get(Ai, Aj) * B->get(Bi, Bj);
							// int Ai = (i + y)%A->m_stored_lines, Aj = (k + q)%A->m_stored_column;
							// int Bi = (k + q)%B->m_stored_lines, Bj = (j + x)%B->m_stored_column;
							
							// acc += A->get(Ai, Aj) * B->get(Bi, Bj);
						}
					}
					C->set(Ci, Cj, acc);
				}
			}
		}
	}


	// Above lines just set the padding of the matrix to an identity like matrix
	for(int j=0; j<C->m_stored_column - C->columns(); j++)
	{
		for(int i=0; i<C->lines(); i++)
		{
			int block_y = i/C->m_block_heigth;
			int block_x = (C->columns() + j)/C->m_block_width;

			int y = i - block_y*C->m_block_heigth;
			int x = (C->columns() + j) - block_x*C->m_block_width;

			C->m_data[C->stride(block_y, block_x) + y*C->m_block_width + x] = 0.f;
		}
	}
	for(int i=0; i<C->m_stored_lines - C->lines(); i++)
	{
		for(int j=0; j<C->columns(); j++)
		{
			int block_y = (C->lines() + i)/C->m_block_heigth;
			int block_x = j/C->m_block_width;

			int y = (C->lines() + i) - block_y*C->m_block_heigth;
			int x = j - block_x*C->m_block_width;

			C->m_data[C->stride(block_y, block_x) + y*C->m_block_width + x] = 0.f;
		}
	}
	for(int i=0; i<std::min(C->m_stored_lines - C->lines(), C->m_stored_column - C->columns()); i++)
	{
		int block_y = (C->lines() + i)/C->m_block_heigth;
		int block_x = (C->columns() + i)/C->m_block_width;

		int y = (C->lines() + i) - block_y*C->m_block_heigth;
		int x = (C->columns() + i) - block_x*C->m_block_width;

		C->m_data[C->stride(block_y, block_x) + y*C->m_block_width + x] = 1.f;
	}
}

void MatrixMultiplayer::mul(matrix* C, const matrix* const A, const double alpha)
{
	// code for GPU multiplication
	for(int i=0; i<C->lines(); i+= C->blockHeight()) 
	{
		for(int j=0; j<C->columns(); j+= C->blockWidth()) 
		{
			// loops above will become one block
			for(int y=0; y<C->m_block_heigth; y++)
			{
				for(int x=0; x<C->m_block_width; x++)
				{
					// loops above will become one thread
					int Ci = i + y, Cj = j + x;
					C->set(Ci, Cj, A->get(Ci, Cj)*alpha);
				}
			}
		}
	}

	for(int i=0; i<std::min(C->m_stored_lines - C->lines(), C->m_stored_column - C->columns()); i++)
	{
		int block_y = (C->lines() + i)/C->m_block_heigth;
		int block_x = (C->columns() + i)/C->m_block_width;

		int y = (C->lines() + i) - block_y*C->m_block_heigth;
		int x = (C->columns() + i) - block_x*C->m_block_width;

		C->m_data[C->stride(block_y, block_x) + y*C->m_block_width + x] = 1.f;
	}

	return;
}


matrix& matrix::operator=(const matrix& other)
{

	this->m_data = other.m_data;
	return *this;
}

matrix matrix::operator+(const matrix& other)
{
	matrix C(this->lines(), this->columns(),  this->blockHeight(), other.blockWidth());
	
    add(&C, this, &other, false, false);
	
    return C;
}

matrix matrix::operator-(const matrix& other)
{
	matrix C(this->lines(), this->columns(),  this->blockHeight(), other.blockWidth());
	
    sub(&C, this, &other, false, false);
	
    return C;
}

matrix matrix::operator*(const matrix& other)
{
	// std::cout << "ASDASD\n";
	if(other.columns() == 1 && other.rows() == 1)
	{
		matrix D(this->rows(), this->columns(),  this->blockWidth(), this->blockHeight());
		MatrixMultiplayer::mul(&D.m_data, &this->m_data, other.get(0,0));
		return D;
	}

	if(this->columns() == 1 && this->rows() == 1)
	{
		matrix D(other.rows(), other.columns(),  other.blockWidth(), other.blockHeight());
		MatrixMultiplayer::mul(&D.m_data, &other.m_data, this->get(0,0));
		return D;
	}

	matrix C(this->lines(), other.columns(),  this->blockWidth(), other.blockHeight());
	MatrixMultiplayer::mul(&C.m_data, &this->m_data, &other.m_data, false, false);
	return C;
}

matrix matrix::operator/(const matrix& other)
{
	if(other.columns() == 1 && other.rows() == 1)
	{
		matrix D(this->rows(), this->columns(),  this->blockWidth(), this->blockHeight());
		div(&D.m_data, &this->m_data, other.get(0,0));
		return D;
	}

	if(this->columns() == 1 && this->rows() == 1)
	{
		matrix D(other.rows(), other.columns(),  other.blockWidth(), other.blockHeight());
		div(&D.m_data, &other.m_data, this->get(0,0));
		return D;
	}

	matrix C(this->lines(), other.columns(),  this->blockWidth(), other.blockHeight());
	div(&C.m_data, &this->m_data, &other.m_data, false, false);
	return C;
}

matrix matrix::operator/(const double other)
{
	matrix C(this->lines(), this->columns(),  this->blockWidth(), this->blockHeight());
	div(&C.m_data, &this->m_data, other);
	return C;
}

matrix matrix::operator*(const double other)
{
	matrix C(this->lines(), this->columns(),  this->blockWidth(), this->blockHeight());
	MatrixMultiplayer::mul(&C.m_data, &this->m_data, other);
	return C;
}


matrix::MatrixLineGetter::MatrixLineGetter(matrix* parent, unsigned int line)
{
	this->line = line;
	this->parent = parent;
}

double& matrix::MatrixLineGetter::operator[](const unsigned int idx)
{
	return parent->m_data.get(this->line, idx);
}

matrix::MatrixLineGetter matrix::operator[](const unsigned int idx)
{
	return matrix::MatrixLineGetter(this, idx);
}

matrix::~matrix(){}

const unsigned int matrix::rows() const
{
	return this->lines();
}

const unsigned int matrix::columns() const
{
	return this->columns();
}

matrix transpose(matrix& other)
{
	matrix C(other.columns(), other.rows(),  other.blockHeight(), other.blockWidth());
	transpose(&C, &other);
	return C;
}

matrix transpose(matrix&& other)
{
	matrix C(other.columns(), other.rows(),  other.blockHeight(), other.blockWidth());
	transpose(&C, &other);
	return C;
}

matrix transpose(matrix* other)
{
	matrix C(other->columns(), other->rows(),  other->blockHeight(), other->m_data.blockWidth());
	transpose(&C, other);
	return C;
}

std::pair<matrix, matrix> LUDecomposition(const matrix* const A)
{
	matrix L(A->rows(), A->columns(), A->m_data.blockWidth(), A->m_data.blockHeight());
	matrix U(A->rows(), A->columns(), A->m_data.blockWidth(), A->m_data.blockHeight());
	LUdecompose(&L.m_data, &U.m_data, &A->m_data);
	return {L, U};
}

std::pair<matrix, matrix> LUDecomposition(const matrix& A)
{
	matrix L(A.rows(), A.columns(), A.m_data.blockWidth(), A.m_data.blockHeight());
	matrix U(A.rows(), A.columns(), A.m_data.blockWidth(), A.m_data.blockHeight());
	LUdecompose(&L.m_data, &U.m_data, &A.m_data);
	return {L, U};
}

std::pair<matrix, matrix> LUPDecomposition(const matrix& A)
{
	matrix R = matrix(A);
	matrix P(A.rows()+1, 1);
	LUPdecompose(&R.m_data, &P.m_data);
	return {R, P};
}

matrix LUPSolve(const matrix& A, const matrix& P, const matrix& b)
{
	matrix x(A.rows(), 1);
	LUPSolve(&A.m_data, &P.m_data, &b.m_data, &x.m_data);
	return x;
}

matrix LUPInverse(const matrix& A, const matrix& P)
{
	matrix Inv(A.rows(), A.columns(), A.m_data.blockWidth(), A.m_data.blockHeight());
	LUPInvet(&A.m_data, &P.m_data, &Inv.m_data);
	return Inv;
}

double LUPDeterminant(const matrix& A, const matrix& P)
{
	return LUPDeterminant(&A.m_data, &P.m_data);
}

matrix echelonForm(matrix matrix)
{
	MatrixEchelonForm::toEchelonForm(&matrix.m_data);
	return matrix;
}

matrix nullspace(matrix matrix)
{
	matrix null;
	MatrixNullSpace::nullSpace(&matrix.m_data, null);
	return matrix(null);
}

matrix diag(matrix&& diag) 
{
	matrix a(diag.rows(),diag.rows());
	for(int i=0; i<diag.rows(); i++)
		a[i][i] = diag[i][0];
	return a;
}

matrix diag(matrix& diag) 
{
	matrix a(diag.rows(),diag.rows());
	for(int i=0; i<diag.rows(); i++)
		a[i][i] = diag[i][0];
	return a;
}

matrix diag(double* diag, unsigned int n) 
{
	matrix a(n,n);
	for(int i=0; i<n; i++)
		a[i][i] = diag[i];
	return a;
}

matrix diag(double* diag, unsigned int m, unsigned int n) 
{
	matrix a(m,n);

	for(int i=0; i<std::min(n, m); i++)
		a[i][i] = diag[i];

	return a;
}

matrix bidiag(double* diag, double* sdiag, unsigned int m, unsigned int n) 
{
	matrix a(m,n);

	for(int i=0; i<std::min(n, m); i++)
	{
		a[i][i] = diag[i];
	
		if(i < std::min(n,m) - 1)
		{
			a[i][i+1] = sdiag[i+1];
		}
	}

	return a;
}

matrix diag(matrix&& diag, unsigned int m, unsigned int n) 
{
	assert(diag.rows() == n);
	matrix a(m,n);
	for(int i=0; i<std::min(n, m); i++)
		a[i][i] = diag[i][0];
	return a;
}

matrix diag(matrix& diag, unsigned int m, unsigned int n) 
{
	assert(diag.rows() == n);

	matrix a(m,n);
	for(int i=0; i<n; i++)
		a[i][i] = diag[i][0];
	return a;
}

void printMatrixWithMargin(matrix* A, unsigned precision, double eps)
{
	for(int i=0;i<A->m_data.m_stored_lines; i++)
	{
		for(int j=0; j<A->m_data.m_stored_column;j++)
		{
			double val = fabs(A->m_data.get(i,j)) > eps ? A->m_data.get(i,j) : 0.0;
			std::cout << std::fixed << std::setprecision(precision) << std::setw(precision+8) << val << " ";
		}
		std::cout << std::endl;
	}
}

void printMatrixWithMargin(matrix& A, unsigned precision, double eps)
{
	for(int i=0;i<A.m_data.m_stored_lines; i++)
	{
		for(int j=0; j<A.m_data.m_stored_column;j++)
		{
			double val = fabs(A.m_data.get(i,j)) > eps ? A.m_data.get(i,j) : 0.0;

			std::cout << std::fixed << std::setprecision(precision) << std::setw(precision+8) <<val << " ";
		}
		std::cout << std::endl;
	}
}

void printMatrix(matrix* A, unsigned precision, double eps)
{
	for(int i=0;i<A->m_data.m_lines; i++)
	{
		for(int j=0; j<A->m_data.m_columns;j++)
		{
			double val = fabs(A->m_data.get(i,j)) > eps ? A->m_data.get(i,j) : 0.0;

			std::cout << std::scientific << std::setprecision(precision) << std::setw(precision+8) << val << ", ";
		}
		std::cout << std::endl;
	}
}

void printMatrix(matrix& A, unsigned precision, double eps)
{
	for(int i=0;i<A.m_data.m_lines; i++)
	{
		for(int j=0; j<A.m_data.m_columns;j++)
		{
			double val = fabs(A.m_data.get(i,j)) > eps ? A.m_data.get(i,j) : 0.0;

			std::cout << std::scientific << std::setprecision(precision) << std::setw(precision+8) <<val << ", ";
		}
		std::cout << std::endl;
	}
}

void printSubMatrix(matrix& A, int p, int q, int r, int s, unsigned precision, double eps)
{
	for(int i=p;i<q; i++)
	{
		for(int j=r; j<s;j++)
		{
			double val = fabs(A.m_data.get(i,j)) > eps ? A.m_data.get(i,j) : 0.0;

			std::cout << std::scientific << std::setprecision(precision) << std::setw(precision+8) <<val << ", ";
		}
		std::cout << std::endl;
	}
}

// void printMatrix(matrix&& A, unsigned precision, double eps)
// {
// 	for(int i=0;i<A.m_data.m_lines; i++)
// 	{
// 		for(int j=0; j<A.m_data.m_columns;j++)
// 		{			
// 			double val = fabs(A.m_data.get(i,j)) > eps ? A.m_data.get(i,j) : 0.0;
		
// 			std::cout << std::scientific << std::setprecision(precision) << std::setw(precision+8) <<val << ", ";
// 		}
// 		std::cout << std::endl;
// 	}
// }

matrix identity(unsigned int m, unsigned int n)
{
	matrix I(m, n);

	for(int i = 0; i < std::min(n, m); i++)
	{
		I[i][i] = 1.0;
	}

	return I;
}



