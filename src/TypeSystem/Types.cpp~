#include "Types.hpp"

#include <cstddef>
#include <cstdlib>
#include <cstring>
#include <cassert>

#define BUCKET_SIZE_LOG2 0x00000007
#define BUCKET_SIZE (1 << BUCKET_SIZE_LOG2)

#define TERM_INDEX_MASK BUCKET_SIZE_LOG2
#define TERM_BUCKET_MASK ~TERM_INDEX_MASK

#define build_key(bucket, index) (index & (bucket << BUCKET_SIZE_LOG2))

#define key_bucket(k) ((k & TERM_BUCKET_MASK) >> BUCKET_SIZE_LOG2)
#define key_index(k) (k & TERM_INDEX_MASK)

struct context {
	term** terms;
	name** names;

	key** childs;

	size_t t_count;
	size_t b_count;
};

context* context_create() {
	context* ctx = new context();

	ctx->terms    = new term*[1];
	ctx->terms[0] = new term[BUCKET_SIZE];

	ctx->names    = new name*[1];
	ctx->names[0] = new name[BUCKET_SIZE];

	ctx->childs    = new key*[1];
	ctx->childs[0] = new key[BUCKET_SIZE];

	ctx->t_count = 0;
	ctx->b_count = 1;

	return ctx;
}

void context_destroy(context* ctx) {
	for(size_t i = 0; i < ctx->b_count; i++) {
		delete[] ctx->terms[i];
		delete[] ctx->names[i];
		delete[] ctx->childs;
	}

	delete[] ctx->terms;
	delete[] ctx->names;
	delete[] ctx->childs;

	delete[] ctx;
}

key context_insert(context* ctx, name nm, term::kind kind, key* childs, size_t count) {
	key buckt = ctx->t_count / BUCKET_SIZE;

	// increase buckets of the context if necessary
	if(buckt == ctx->b_count) {
		ctx->b_count = ctx->b_count + 1;

		name** old_names = ctx->names;
		term** old_terms = ctx->terms;

		ctx->terms = new term*[ctx->b_count];
		ctx->names = new name*[ctx->b_count];

		for(size_t i = 0; i < ctx->b_count - 1; i++) {
				ctx->terms[i] = old_terms[i];
				ctx->names[i] = old_names[i];
		}

		delete[] old_terms;
		delete[] old_names;
	}


	key index = ctx->t_count % BUCKET_SIZE;

	ctx->terms[buckt][index] = tp;
	ctx->names[buckt][index] = nm;

	ctx->t_count = ctx->t_count + 1;

	return build_key(buckt, index);
}

key context_get_child_key(context* ctx, term& t, size_t i) {
	key c_key = t.term_childs_idx;

	size_t bck = key_bucket(c_key);
	size_t idx = key_index(c_key);

	assert(ctx->childs[bck][idx] > i /* out of bounds */);

	// first element is the number of childs
	idx += 1;

	bck += (idx + i) / BUCKET_SIZE;

	return ctx->childs[bck][(idx + i) % BUCKET_SIZE];
}

term &context_get_term_from_key(context *ctx, key idx) {
  return ctx->terms[key_bucket(idx)][key_index(idx)];
}

term &context_get_child_term(context *ctx, term &t, size_t i) {
  return context_get_term_from_key(ctx, context_get_child_key(ctx, t, i));
}

// void create_variable() {}
// void create_call() {}
